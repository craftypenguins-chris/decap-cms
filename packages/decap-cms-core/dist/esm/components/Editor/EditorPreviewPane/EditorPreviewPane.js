import _styled from "@emotion/styled/base";
import PropTypes from 'prop-types';
import React from 'react';
import { List, Map } from 'immutable';
import ImmutablePropTypes from 'react-immutable-proptypes';
import Frame, { FrameContextConsumer } from 'react-frame-component';
import { lengths } from 'decap-cms-ui-default';
import { connect } from 'react-redux';
import { encodeEntry } from '../../../lib/stega';
import { resolveWidget, getPreviewTemplate, getPreviewStyles, getRemarkPlugins } from '../../../lib/registry';
import { getAllEntries, tryLoadEntry } from '../../../actions/entries';
import { ErrorBoundary } from '../../UI';
import { selectTemplateName, selectInferredField, selectField } from '../../../reducers/collections';
import { boundGetAsset } from '../../../actions/media';
import { selectIsLoadingAsset } from '../../../reducers/medias';
import { INFERABLE_FIELDS } from '../../../constants/fieldInference';
import EditorPreviewContent from './EditorPreviewContent.js';
import PreviewHOC from './PreviewHOC';
import EditorPreview from './EditorPreview';
import { jsx as ___EmotionJSX } from "@emotion/react";
const PreviewPaneFrame = /*#__PURE__*/_styled(Frame, {
  target: "enus48h1",
  label: "PreviewPaneFrame"
})("width:100%;height:100%;border:none;background:#fff;border-radius:", lengths.borderRadius, ";" + (process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0VkaXRvci9FZGl0b3JQcmV2aWV3UGFuZS9FZGl0b3JQcmV2aWV3UGFuZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUE4QnNDIiwiZmlsZSI6Ii4uLy4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0VkaXRvci9FZGl0b3JQcmV2aWV3UGFuZS9FZGl0b3JQcmV2aWV3UGFuZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHN0eWxlZCBmcm9tICdAZW1vdGlvbi9zdHlsZWQnO1xuaW1wb3J0IHsgTGlzdCwgTWFwIH0gZnJvbSAnaW1tdXRhYmxlJztcbmltcG9ydCBJbW11dGFibGVQcm9wVHlwZXMgZnJvbSAncmVhY3QtaW1tdXRhYmxlLXByb3B0eXBlcyc7XG5pbXBvcnQgRnJhbWUsIHsgRnJhbWVDb250ZXh0Q29uc3VtZXIgfSBmcm9tICdyZWFjdC1mcmFtZS1jb21wb25lbnQnO1xuaW1wb3J0IHsgbGVuZ3RocyB9IGZyb20gJ2RlY2FwLWNtcy11aS1kZWZhdWx0JztcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5cbmltcG9ydCB7IGVuY29kZUVudHJ5IH0gZnJvbSAnLi4vLi4vLi4vbGliL3N0ZWdhJztcbmltcG9ydCB7XG4gIHJlc29sdmVXaWRnZXQsXG4gIGdldFByZXZpZXdUZW1wbGF0ZSxcbiAgZ2V0UHJldmlld1N0eWxlcyxcbiAgZ2V0UmVtYXJrUGx1Z2lucyxcbn0gZnJvbSAnLi4vLi4vLi4vbGliL3JlZ2lzdHJ5JztcbmltcG9ydCB7IGdldEFsbEVudHJpZXMsIHRyeUxvYWRFbnRyeSB9IGZyb20gJy4uLy4uLy4uL2FjdGlvbnMvZW50cmllcyc7XG5pbXBvcnQgeyBFcnJvckJvdW5kYXJ5IH0gZnJvbSAnLi4vLi4vVUknO1xuaW1wb3J0IHtcbiAgc2VsZWN0VGVtcGxhdGVOYW1lLFxuICBzZWxlY3RJbmZlcnJlZEZpZWxkLFxuICBzZWxlY3RGaWVsZCxcbn0gZnJvbSAnLi4vLi4vLi4vcmVkdWNlcnMvY29sbGVjdGlvbnMnO1xuaW1wb3J0IHsgYm91bmRHZXRBc3NldCB9IGZyb20gJy4uLy4uLy4uL2FjdGlvbnMvbWVkaWEnO1xuaW1wb3J0IHsgc2VsZWN0SXNMb2FkaW5nQXNzZXQgfSBmcm9tICcuLi8uLi8uLi9yZWR1Y2Vycy9tZWRpYXMnO1xuaW1wb3J0IHsgSU5GRVJBQkxFX0ZJRUxEUyB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy9maWVsZEluZmVyZW5jZSc7XG5pbXBvcnQgRWRpdG9yUHJldmlld0NvbnRlbnQgZnJvbSAnLi9FZGl0b3JQcmV2aWV3Q29udGVudC5qcyc7XG5pbXBvcnQgUHJldmlld0hPQyBmcm9tICcuL1ByZXZpZXdIT0MnO1xuaW1wb3J0IEVkaXRvclByZXZpZXcgZnJvbSAnLi9FZGl0b3JQcmV2aWV3JztcblxuY29uc3QgUHJldmlld1BhbmVGcmFtZSA9IHN0eWxlZChGcmFtZSlgXG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG4gIGJvcmRlcjogbm9uZTtcbiAgYmFja2dyb3VuZDogI2ZmZjtcbiAgYm9yZGVyLXJhZGl1czogJHtsZW5ndGhzLmJvcmRlclJhZGl1c307XG5gO1xuXG5jb25zdCBFeHRlcm5hbFByZXZpZXdJZnJhbWUgPSBzdHlsZWQuaWZyYW1lYFxuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xuICBib3JkZXI6IG5vbmU7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBiYWNrZ3JvdW5kOiAjZmZmO1xuICBib3JkZXItcmFkaXVzOiAke2xlbmd0aHMuYm9yZGVyUmFkaXVzfTtcbmA7XG5cbmV4cG9ydCBjbGFzcyBQcmV2aWV3UGFuZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGdldFdpZGdldCA9IChmaWVsZCwgdmFsdWUsIG1ldGFkYXRhLCBwcm9wcywgaWR4ID0gbnVsbCkgPT4ge1xuICAgIGNvbnN0IHsgZ2V0QXNzZXQsIGVudHJ5IH0gPSBwcm9wcztcbiAgICBjb25zdCB3aWRnZXQgPSByZXNvbHZlV2lkZ2V0KGZpZWxkLmdldCgnd2lkZ2V0JykpO1xuICAgIGNvbnN0IGtleSA9IGlkeCA/IGZpZWxkLmdldCgnbmFtZScpICsgJ18nICsgaWR4IDogZmllbGQuZ2V0KCduYW1lJyk7XG4gICAgY29uc3QgdmFsdWVJc0luTWFwID0gdmFsdWUgJiYgIXdpZGdldC5hbGxvd01hcFZhbHVlICYmIE1hcC5pc01hcCh2YWx1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBVc2UgYW4gSE9DIHRvIHByb3ZpZGUgY29uZGl0aW9uYWwgdXBkYXRlcyBmb3IgYWxsIHByZXZpZXdzLlxuICAgICAqL1xuICAgIHJldHVybiAhd2lkZ2V0LnByZXZpZXcgPyBudWxsIDogKFxuICAgICAgPFByZXZpZXdIT0NcbiAgICAgICAgcHJldmlld0NvbXBvbmVudD17d2lkZ2V0LnByZXZpZXd9XG4gICAgICAgIGtleT17a2V5fVxuICAgICAgICBmaWVsZD17ZmllbGR9XG4gICAgICAgIGdldEFzc2V0PXtnZXRBc3NldH1cbiAgICAgICAgdmFsdWU9e3ZhbHVlSXNJbk1hcCA/IHZhbHVlLmdldChmaWVsZC5nZXQoJ25hbWUnKSkgOiB2YWx1ZX1cbiAgICAgICAgZW50cnk9e2VudHJ5fVxuICAgICAgICBmaWVsZHNNZXRhRGF0YT17bWV0YWRhdGF9XG4gICAgICAgIHJlc29sdmVXaWRnZXQ9e3Jlc29sdmVXaWRnZXR9XG4gICAgICAgIGdldFJlbWFya1BsdWdpbnM9e2dldFJlbWFya1BsdWdpbnN9XG4gICAgICAvPlxuICAgICk7XG4gIH07XG5cbiAgaW5mZXJyZWRGaWVsZHMgPSB7fTtcblxuICBpbmZlckZpZWxkcygpIHtcbiAgICBjb25zdCB0aXRsZUZpZWxkID0gc2VsZWN0SW5mZXJyZWRGaWVsZCh0aGlzLnByb3BzLmNvbGxlY3Rpb24sICd0aXRsZScpO1xuICAgIGNvbnN0IHNob3J0VGl0bGVGaWVsZCA9IHNlbGVjdEluZmVycmVkRmllbGQodGhpcy5wcm9wcy5jb2xsZWN0aW9uLCAnc2hvcnRUaXRsZScpO1xuICAgIGNvbnN0IGF1dGhvckZpZWxkID0gc2VsZWN0SW5mZXJyZWRGaWVsZCh0aGlzLnByb3BzLmNvbGxlY3Rpb24sICdhdXRob3InKTtcblxuICAgIHRoaXMuaW5mZXJyZWRGaWVsZHMgPSB7fTtcbiAgICBpZiAodGl0bGVGaWVsZCkgdGhpcy5pbmZlcnJlZEZpZWxkc1t0aXRsZUZpZWxkXSA9IElORkVSQUJMRV9GSUVMRFMudGl0bGU7XG4gICAgaWYgKHNob3J0VGl0bGVGaWVsZCkgdGhpcy5pbmZlcnJlZEZpZWxkc1tzaG9ydFRpdGxlRmllbGRdID0gSU5GRVJBQkxFX0ZJRUxEUy5zaG9ydFRpdGxlO1xuICAgIGlmIChhdXRob3JGaWVsZCkgdGhpcy5pbmZlcnJlZEZpZWxkc1thdXRob3JGaWVsZF0gPSBJTkZFUkFCTEVfRklFTERTLmF1dGhvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWRnZXQgY29tcG9uZW50IGZvciBhIG5hbWVkIGZpZWxkLCBhbmQgbWFrZXMgcmVjdXJzaXZlIGNhbGxzXG4gICAqIHRvIHJldHJpZXZlIGNvbXBvbmVudHMgZm9yIG5lc3RlZCBhbmQgZGVlcGx5IG5lc3RlZCBmaWVsZHMsIHdoaWNoIG9jY3VyIGluXG4gICAqIG9iamVjdCBhbmQgbGlzdCB0eXBlIGZpZWxkcy4gVXNlZCBpbnRlcm5hbGx5IHRvIHJldHJpZXZlIHdpZGdldHMsIGFuZCBhbHNvXG4gICAqIGV4cG9zZWQgZm9yIHVzZSBpbiBjdXN0b20gcHJldmlldyB0ZW1wbGF0ZXMuXG4gICAqL1xuICB3aWRnZXRGb3IgPSAoXG4gICAgbmFtZSxcbiAgICBmaWVsZHMgPSB0aGlzLnByb3BzLmZpZWxkcyxcbiAgICB2YWx1ZXMgPSB0aGlzLnByb3BzLmVudHJ5LmdldCgnZGF0YScpLFxuICAgIGZpZWxkc01ldGFEYXRhID0gdGhpcy5wcm9wcy5maWVsZHNNZXRhRGF0YSxcbiAgKSA9PiB7XG4gICAgLy8gV2UgcmV0cmlldmUgdGhlIGZpZWxkIGJ5IG5hbWUgc28gdGhhdCB0aGlzIGZ1bmN0aW9uIGNhbiBhbHNvIGJlIHVzZWQgaW5cbiAgICAvLyBjdXN0b20gcHJldmlldyB0ZW1wbGF0ZXMsIHdoZXJlIHRoZSBmaWVsZCBvYmplY3QgY2FuJ3QgYmUgcGFzc2VkIGluLlxuICAgIGxldCBmaWVsZCA9IGZpZWxkcyAmJiBmaWVsZHMuZmluZChmID0+IGYuZ2V0KCduYW1lJykgPT09IG5hbWUpO1xuICAgIGxldCB2YWx1ZSA9IE1hcC5pc01hcCh2YWx1ZXMpICYmIHZhbHVlcy5nZXQoZmllbGQuZ2V0KCduYW1lJykpO1xuICAgIGlmIChmaWVsZC5nZXQoJ21ldGEnKSkge1xuICAgICAgdmFsdWUgPSB0aGlzLnByb3BzLmVudHJ5LmdldEluKFsnbWV0YScsIGZpZWxkLmdldCgnbmFtZScpXSk7XG4gICAgfVxuXG4gICAgY29uc3QgbmVzdGVkRmllbGRzID0gZmllbGQuZ2V0KCdmaWVsZHMnKTtcbiAgICBjb25zdCBzaW5nbGVGaWVsZCA9IGZpZWxkLmdldCgnZmllbGQnKTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGZpZWxkc01ldGFEYXRhICYmIGZpZWxkc01ldGFEYXRhLmdldChmaWVsZC5nZXQoJ25hbWUnKSwgTWFwKCkpO1xuXG4gICAgaWYgKG5lc3RlZEZpZWxkcykge1xuICAgICAgZmllbGQgPSBmaWVsZC5zZXQoJ2ZpZWxkcycsIHRoaXMuZ2V0TmVzdGVkV2lkZ2V0cyhuZXN0ZWRGaWVsZHMsIHZhbHVlLCBtZXRhZGF0YSkpO1xuICAgIH1cblxuICAgIGlmIChzaW5nbGVGaWVsZCkge1xuICAgICAgZmllbGQgPSBmaWVsZC5zZXQoJ2ZpZWxkJywgdGhpcy5nZXRTaW5nbGVOZXN0ZWQoc2luZ2xlRmllbGQsIHZhbHVlLCBtZXRhZGF0YSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVsbGVkV2lkZ2V0cyA9IFsnc3RyaW5nJywgJ3RleHQnLCAnbnVtYmVyJ107XG4gICAgY29uc3QgaW5mZXJyZWRGaWVsZCA9IE9iamVjdC5lbnRyaWVzKHRoaXMuaW5mZXJyZWRGaWVsZHMpXG4gICAgICAuZmlsdGVyKChba2V5XSkgPT4ge1xuICAgICAgICBjb25zdCBmaWVsZFRvTWF0Y2ggPSBzZWxlY3RGaWVsZCh0aGlzLnByb3BzLmNvbGxlY3Rpb24sIGtleSk7XG4gICAgICAgIHJldHVybiBmaWVsZFRvTWF0Y2ggPT09IGZpZWxkO1xuICAgICAgfSlcbiAgICAgIC5tYXAoKFssIHZhbHVlXSkgPT4gdmFsdWUpWzBdO1xuXG4gICAgaWYgKGluZmVycmVkRmllbGQpIHtcbiAgICAgIHZhbHVlID0gaW5mZXJyZWRGaWVsZC5kZWZhdWx0UHJldmlldyh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHZhbHVlICYmXG4gICAgICBsYWJlbGxlZFdpZGdldHMuaW5kZXhPZihmaWVsZC5nZXQoJ3dpZGdldCcpKSAhPT0gLTEgJiZcbiAgICAgIHZhbHVlLnRvU3RyaW5nKCkubGVuZ3RoIDwgNTBcbiAgICApIHtcbiAgICAgIHZhbHVlID0gKFxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxzdHJvbmc+e2ZpZWxkLmdldCgnbGFiZWwnLCBmaWVsZC5nZXQoJ25hbWUnKSl9Ojwvc3Ryb25nPiB7dmFsdWV9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUgPyB0aGlzLmdldFdpZGdldChmaWVsZCwgdmFsdWUsIG1ldGFkYXRhLCB0aGlzLnByb3BzKSA6IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB3aWRnZXRzIGZvciBuZXN0ZWQgZmllbGRzIChjaGlsZHJlbiBvZiBvYmplY3QvbGlzdCBmaWVsZHMpXG4gICAqL1xuICBnZXROZXN0ZWRXaWRnZXRzID0gKGZpZWxkcywgdmFsdWVzLCBmaWVsZHNNZXRhRGF0YSkgPT4ge1xuICAgIC8vIEZpZWxkcyBuZXN0ZWQgd2l0aGluIGEgbGlzdCBmaWVsZCB3aWxsIGJlIHBhaXJlZCB3aXRoIGEgTGlzdCBvZiB2YWx1ZSBNYXBzLlxuICAgIGlmIChMaXN0LmlzTGlzdCh2YWx1ZXMpKSB7XG4gICAgICByZXR1cm4gdmFsdWVzLm1hcCh2YWx1ZSA9PiB0aGlzLndpZGdldHNGb3JOZXN0ZWRGaWVsZHMoZmllbGRzLCB2YWx1ZSwgZmllbGRzTWV0YURhdGEpKTtcbiAgICB9XG4gICAgLy8gRmllbGRzIG5lc3RlZCB3aXRoaW4gYW4gb2JqZWN0IGZpZWxkIHdpbGwgYmUgcGFpcmVkIHdpdGggYSBzaW5nbGUgTWFwIG9mIHZhbHVlcy5cbiAgICByZXR1cm4gdGhpcy53aWRnZXRzRm9yTmVzdGVkRmllbGRzKGZpZWxkcywgdmFsdWVzLCBmaWVsZHNNZXRhRGF0YSk7XG4gIH07XG5cbiAgZ2V0U2luZ2xlTmVzdGVkID0gKGZpZWxkLCB2YWx1ZXMsIGZpZWxkc01ldGFEYXRhKSA9PiB7XG4gICAgaWYgKExpc3QuaXNMaXN0KHZhbHVlcykpIHtcbiAgICAgIHJldHVybiB2YWx1ZXMubWFwKCh2YWx1ZSwgaWR4KSA9PlxuICAgICAgICB0aGlzLmdldFdpZGdldChmaWVsZCwgdmFsdWUsIGZpZWxkc01ldGFEYXRhLmdldChmaWVsZC5nZXQoJ25hbWUnKSksIHRoaXMucHJvcHMsIGlkeCksXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRXaWRnZXQoZmllbGQsIHZhbHVlcywgZmllbGRzTWV0YURhdGEuZ2V0KGZpZWxkLmdldCgnbmFtZScpKSwgdGhpcy5wcm9wcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVzZSB3aWRnZXRGb3IgYXMgYSBtYXBwaW5nIGZ1bmN0aW9uIGZvciByZWN1cnNpdmUgd2lkZ2V0IHJldHJpZXZhbFxuICAgKi9cbiAgd2lkZ2V0c0Zvck5lc3RlZEZpZWxkcyA9IChmaWVsZHMsIHZhbHVlcywgZmllbGRzTWV0YURhdGEpID0+IHtcbiAgICByZXR1cm4gZmllbGRzLm1hcChmaWVsZCA9PiB0aGlzLndpZGdldEZvcihmaWVsZC5nZXQoJ25hbWUnKSwgZmllbGRzLCB2YWx1ZXMsIGZpZWxkc01ldGFEYXRhKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gZXhpc3RzIGVudGlyZWx5IHRvIGV4cG9zZSBuZXN0ZWQgd2lkZ2V0cyBmb3Igb2JqZWN0IGFuZCBsaXN0XG4gICAqIGZpZWxkcyB0byBjdXN0b20gcHJldmlldyB0ZW1wbGF0ZXMuXG4gICAqXG4gICAqIFRPRE86IHNlZSBpZiB3aWRnZXRGb3IgY2FuIG5vdyBwcm92aWRlIHRoaXMgZnVuY3Rpb25hbGl0eSBmb3IgcHJldmlldyB0ZW1wbGF0ZXNcbiAgICovXG4gIHdpZGdldHNGb3IgPSBuYW1lID0+IHtcbiAgICBjb25zdCB7IGZpZWxkcywgZW50cnksIGZpZWxkc01ldGFEYXRhIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGZpZWxkID0gZmllbGRzLmZpbmQoZiA9PiBmLmdldCgnbmFtZScpID09PSBuYW1lKTtcbiAgICBjb25zdCBuZXN0ZWRGaWVsZHMgPSBmaWVsZCAmJiBmaWVsZC5nZXQoJ2ZpZWxkcycpO1xuICAgIGNvbnN0IHZhcmlhYmxlVHlwZXMgPSBmaWVsZCAmJiBmaWVsZC5nZXQoJ3R5cGVzJyk7XG4gICAgY29uc3QgdmFsdWUgPSBlbnRyeS5nZXRJbihbJ2RhdGEnLCBmaWVsZC5nZXQoJ25hbWUnKV0pO1xuICAgIGNvbnN0IG1ldGFkYXRhID0gZmllbGRzTWV0YURhdGEuZ2V0KGZpZWxkLmdldCgnbmFtZScpLCBNYXAoKSk7XG5cbiAgICAvLyBWYXJpYWJsZSBUeXBlIGxpc3RzXG4gICAgaWYgKExpc3QuaXNMaXN0KHZhbHVlKSAmJiB2YXJpYWJsZVR5cGVzKSB7XG4gICAgICByZXR1cm4gdmFsdWUubWFwKHZhbCA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHZhcmlhYmxlVHlwZXMuZmluZCh0ID0+IHQuZ2V0KCduYW1lJykgPT09IHZhbC5nZXQoJ3R5cGUnKSk7XG4gICAgICAgIGNvbnN0IHR5cGVGaWVsZHMgPSB2YWx1ZVR5cGUgJiYgdmFsdWVUeXBlLmdldCgnZmllbGRzJyk7XG4gICAgICAgIGNvbnN0IHdpZGdldHMgPVxuICAgICAgICAgIHR5cGVGaWVsZHMgJiZcbiAgICAgICAgICBNYXAoXG4gICAgICAgICAgICB0eXBlRmllbGRzLm1hcCgoZiwgaSkgPT4gW1xuICAgICAgICAgICAgICBmLmdldCgnbmFtZScpLFxuICAgICAgICAgICAgICA8ZGl2IGtleT17aX0+e3RoaXMuZ2V0V2lkZ2V0KGYsIHZhbCwgbWV0YWRhdGEuZ2V0KGYuZ2V0KCduYW1lJykpLCB0aGlzLnByb3BzKX08L2Rpdj4sXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gTWFwKHsgZGF0YTogdmFsLCB3aWRnZXRzIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gTGlzdCB3aWRnZXRzXG4gICAgaWYgKExpc3QuaXNMaXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLm1hcCh2YWwgPT4ge1xuICAgICAgICBjb25zdCB3aWRnZXRzID1cbiAgICAgICAgICBuZXN0ZWRGaWVsZHMgJiZcbiAgICAgICAgICBNYXAoXG4gICAgICAgICAgICBuZXN0ZWRGaWVsZHMubWFwKChmLCBpKSA9PiBbXG4gICAgICAgICAgICAgIGYuZ2V0KCduYW1lJyksXG4gICAgICAgICAgICAgIDxkaXYga2V5PXtpfT57dGhpcy5nZXRXaWRnZXQoZiwgdmFsLCBtZXRhZGF0YS5nZXQoZi5nZXQoJ25hbWUnKSksIHRoaXMucHJvcHMpfTwvZGl2PixcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiBNYXAoeyBkYXRhOiB2YWwsIHdpZGdldHMgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gTWFwKHtcbiAgICAgIGRhdGE6IHZhbHVlLFxuICAgICAgd2lkZ2V0czpcbiAgICAgICAgbmVzdGVkRmllbGRzICYmXG4gICAgICAgIE1hcChcbiAgICAgICAgICBuZXN0ZWRGaWVsZHMubWFwKGYgPT4gW1xuICAgICAgICAgICAgZi5nZXQoJ25hbWUnKSxcbiAgICAgICAgICAgIHRoaXMuZ2V0V2lkZ2V0KGYsIHZhbHVlLCBtZXRhZGF0YS5nZXQoZi5nZXQoJ25hbWUnKSksIHRoaXMucHJvcHMpLFxuICAgICAgICAgIF0pLFxuICAgICAgICApLFxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGV4aXN0cyBlbnRpcmVseSB0byBleHBvc2UgY29sbGVjdGlvbnMgZnJvbSBvdXRzaWRlIG9mIHRoaXMgZW50cnlcbiAgICpcbiAgICovXG4gIGdldENvbGxlY3Rpb24gPSBhc3luYyAoY29sbGVjdGlvbk5hbWUsIHNsdWcpID0+IHtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHNlbGVjdGVkQ29sbGVjdGlvbiA9IHN0YXRlLmNvbGxlY3Rpb25zLmdldChjb2xsZWN0aW9uTmFtZSk7XG5cbiAgICBpZiAodHlwZW9mIHNsdWcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgZ2V0QWxsRW50cmllcyhzdGF0ZSwgc2VsZWN0ZWRDb2xsZWN0aW9uKTtcbiAgICAgIHJldHVybiBlbnRyaWVzLm1hcChlbnRyeSA9PiBNYXAoKS5zZXQoJ2RhdGEnLCBlbnRyeS5kYXRhKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZW50cnkgPSBhd2FpdCB0cnlMb2FkRW50cnkoc3RhdGUsIHNlbGVjdGVkQ29sbGVjdGlvbiwgc2x1Zyk7XG4gICAgcmV0dXJuIE1hcCgpLnNldCgnZGF0YScsIGVudHJ5LmRhdGEpO1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGVudHJ5LCBjb2xsZWN0aW9uLCBjb25maWcgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoIWVudHJ5IHx8ICFlbnRyeS5nZXQoJ2RhdGEnKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgcHJldmlld0NvbXBvbmVudCA9XG4gICAgICBnZXRQcmV2aWV3VGVtcGxhdGUoc2VsZWN0VGVtcGxhdGVOYW1lKGNvbGxlY3Rpb24sIGVudHJ5LmdldCgnc2x1ZycpKSkgfHwgRWRpdG9yUHJldmlldztcblxuICAgIHRoaXMuaW5mZXJGaWVsZHMoKTtcblxuICAgIGNvbnN0IHZpc3VhbEVkaXRpbmcgPSBjb2xsZWN0aW9uLmdldEluKFsnZWRpdG9yJywgJ3Zpc3VhbEVkaXRpbmcnXSwgZmFsc2UpO1xuXG4gICAgLy8gT25seSBlbmNvZGUgZW50cnkgZGF0YSBpZiB2aXN1YWwgZWRpdGluZyBpcyBlbmFibGVkXG4gICAgY29uc3QgcHJldmlld0VudHJ5ID0gdmlzdWFsRWRpdGluZ1xuICAgICAgPyBlbnRyeS5zZXQoJ2RhdGEnLCBlbmNvZGVFbnRyeShlbnRyeS5nZXQoJ2RhdGEnKSwgdGhpcy5wcm9wcy5maWVsZHMpKVxuICAgICAgOiBlbnRyeTtcblxuICAgIGNvbnN0IHByZXZpZXdQcm9wcyA9IHtcbiAgICAgIC4uLnRoaXMucHJvcHMsXG4gICAgICBlbnRyeTogcHJldmlld0VudHJ5LFxuICAgICAgd2lkZ2V0Rm9yOiAobmFtZSwgZmllbGRzLCB2YWx1ZXMgPSBwcmV2aWV3RW50cnkuZ2V0KCdkYXRhJyksIGZpZWxkc01ldGFEYXRhKSA9PlxuICAgICAgICB0aGlzLndpZGdldEZvcihuYW1lLCBmaWVsZHMsIHZhbHVlcywgZmllbGRzTWV0YURhdGEpLFxuICAgICAgd2lkZ2V0c0ZvcjogdGhpcy53aWRnZXRzRm9yLFxuICAgICAgZ2V0Q29sbGVjdGlvbjogdGhpcy5nZXRDb2xsZWN0aW9uLFxuICAgIH07XG5cbiAgICBjb25zdCBzdHlsZUVscyA9IGdldFByZXZpZXdTdHlsZXMoKS5tYXAoKHN0eWxlLCBpKSA9PiB7XG4gICAgICBpZiAoc3R5bGUucmF3KSB7XG4gICAgICAgIHJldHVybiA8c3R5bGUga2V5PXtpfT57c3R5bGUudmFsdWV9PC9zdHlsZT47XG4gICAgICB9XG4gICAgICByZXR1cm4gPGxpbmsga2V5PXtpfSBocmVmPXtzdHlsZS52YWx1ZX0gdHlwZT1cInRleHQvY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiIC8+O1xuICAgIH0pO1xuXG4gICAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgICA8UHJldmlld1BhbmVGcmFtZSBpZD1cInByZXZpZXctcGFuZVwiIGhlYWQ9e3N0eWxlRWxzfSAvPjtcbiAgICB9XG5cbiAgICAvLyBGb3IgbG9jYWwgcHJldmlldyBtaXJyb3IgKG9yIGxlZ2FjeSBsb2NhbF9iYWNrZW5kKSwgcmVuZGVyIHRoZSByZWFsIEh1Z28gcGFnZSB2aWEgaWZyYW1lXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGlzTWlycm9yUHJldmlldyA9ICEhKGNvbmZpZyAmJiAoY29uZmlnLmxvY2FsX3ByZXZpZXdfbWlycm9yIHx8IGNvbmZpZy5sb2NhbF9iYWNrZW5kKSk7XG4gICAgICBpZiAoaXNNaXJyb3JQcmV2aWV3KSB7XG4gICAgICAgIGNvbnN0IGZvbGRlciA9IChjb2xsZWN0aW9uLmdldCgnZm9sZGVyJykgfHwgJycpLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIHNlY3Rpb24gZGVyaXZlZCBmcm9tIGZvbGRlciwgZS5nLiwgY29udGVudC90ZWNoLXN0YWNrIC0+IHRlY2gtc3RhY2tcbiAgICAgICAgY29uc3Qgc2VjdGlvbiA9IGZvbGRlci5yZXBsYWNlKC9eXFwvP2NvbnRlbnRcXC8/L2ksICcnKS5yZXBsYWNlKC9eXFwvK3xcXC8rJC9nLCAnJyk7XG4gICAgICAgIGNvbnN0IHNsdWcgPSAoKGVudHJ5LmdldCgnc2x1ZycpIHx8ICcnKS50b1N0cmluZygpKS5yZXBsYWNlKC9eXFwvK3xcXC8rJC9nLCAnJyk7XG4gICAgICAgIGNvbnN0IG5lZWRzU2VjdGlvbiA9IHNlY3Rpb24gJiYgIXNsdWcuc3RhcnRzV2l0aChgJHtzZWN0aW9ufS9gKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IG5lZWRzU2VjdGlvbiA/IGAke3NlY3Rpb259LyR7c2x1Z31gIDogc2x1ZztcbiAgICAgICAgY29uc3QgYmFzZSA9XG4gICAgICAgICAgKGNvbmZpZyAmJiAoY29uZmlnLmdldCAmJiAoY29uZmlnLmdldCgnZGlzcGxheV91cmwnKSB8fCBjb25maWcuZ2V0KCdzaXRlX3VybCcpKSkpIHx8XG4gICAgICAgICAgKGNvbmZpZyAmJiAoKGNvbmZpZy5kaXNwbGF5X3VybCkgfHwgKGNvbmZpZy5zaXRlX3VybCkpKSB8fFxuICAgICAgICAgICgodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pIHx8ICcnKTtcbiAgICAgICAgbGV0IHByZXZpZXdVcmwgPSBgJHtiYXNlfS8ke3BhdGgucmVwbGFjZSgvXlxcLyt8XFwvKyR8XFwvXFwvKyQvZywgJycpfS9gO1xuICAgICAgICAvLyBTdHJpcCB0cmFpbGluZyAnL2luZGV4JyBvciAnL2luZGV4LycgZnJvbSBuZXN0ZWQgaW5kZXgubWQgVVJMc1xuICAgICAgICBwcmV2aWV3VXJsID0gcHJldmlld1VybC5yZXBsYWNlKC9cXC8oaW5kZXhcXC8/KSg/PSR8XFw/KS9pLCAnLycpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUpIHtcbiAgICAgICAgICB0cnkgeyBjb25zb2xlLmxvZygnW2xvY2FsX3ByZXZpZXdfbWlycm9yIHByZXZpZXddIHVybDonLCB7IHNlY3Rpb24sIHNsdWcsIHBhdGgsIHByZXZpZXdVcmwgfSk7IH0gY2F0Y2ggKF8pIHt9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGhlaWdodDogJzEwMCUnLCBkaXNwbGF5OiAnZmxleCcsIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nIH19PlxuICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBwYWRkaW5nOiAnNnB4IDhweCcsIGJvcmRlckJvdHRvbTogJzFweCBzb2xpZCAjZTFlNGU4JywgYmFja2dyb3VuZDogJyNmYWZiZmMnLCBmb250U2l6ZTogMTIgfX0+XG4gICAgICAgICAgICAgIDxzcGFuIHN0eWxlPXt7IG1hcmdpblJpZ2h0OiA4LCB3b3JkQnJlYWs6ICdicmVhay1hbGwnIH19PntwcmV2aWV3VXJsfTwvc3Bhbj5cbiAgICAgICAgICAgICAgPGEgaHJlZj17cHJldmlld1VybH0gdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiIHN0eWxlPXt7IHRleHREZWNvcmF0aW9uOiAnbm9uZScsIGNvbG9yOiAnIzA5NjlkYScgfX0+T3BlbiBpbiBuZXcgdGFiPC9hPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGZsZXg6IDEsIG1pbkhlaWdodDogMCB9fT5cbiAgICAgICAgICAgICAgPEV4dGVybmFsUHJldmlld0lmcmFtZVxuICAgICAgICAgICAgICAgIGlkPVwiaHVnby1leHRlcm5hbC1wcmV2aWV3LWlmcmFtZVwiXG4gICAgICAgICAgICAgICAgc3JjPXtwcmV2aWV3VXJsfVxuICAgICAgICAgICAgICAgIG9uRXJyb3I9eygpID0+IHdpbmRvdy5hbGVydCgnUHJldmlldyBmYWlsZWQgdG8gbG9hZC4gSXMgdGhlIEh1Z28gc2VydmVyIHJ1bm5pbmc/Jyl9XG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScgfX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGZhbGwgYmFjayB0byBkZWZhdWx0IGJlbG93XG4gICAgfVxuXG4gICAgY29uc3QgaW5pdGlhbENvbnRlbnQgPSBgXG48IURPQ1RZUEUgaHRtbD5cbjxodG1sPlxuICA8aGVhZD48YmFzZSB0YXJnZXQ9XCJfYmxhbmtcIi8+PC9oZWFkPlxuICA8Ym9keT48ZGl2PjwvZGl2PjwvYm9keT5cbjwvaHRtbD5cbmA7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEVycm9yQm91bmRhcnkgY29uZmlnPXtjb25maWd9PlxuICAgICAgICA8UHJldmlld1BhbmVGcmFtZSBpZD1cInByZXZpZXctcGFuZVwiIGhlYWQ9e3N0eWxlRWxzfSBpbml0aWFsQ29udGVudD17aW5pdGlhbENvbnRlbnR9PlxuICAgICAgICAgIDxGcmFtZUNvbnRleHRDb25zdW1lcj5cbiAgICAgICAgICAgIHsoeyBkb2N1bWVudCwgd2luZG93IH0pID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8RWRpdG9yUHJldmlld0NvbnRlbnRcbiAgICAgICAgICAgICAgICAgIHsuLi57IHByZXZpZXdDb21wb25lbnQsIHByZXZpZXdQcm9wczogeyAuLi5wcmV2aWV3UHJvcHMsIGRvY3VtZW50LCB3aW5kb3cgfSB9fVxuICAgICAgICAgICAgICAgICAgb25GaWVsZENsaWNrPXt0aGlzLnByb3BzLm9uRmllbGRDbGlja31cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICA8L0ZyYW1lQ29udGV4dENvbnN1bWVyPlxuICAgICAgICA8L1ByZXZpZXdQYW5lRnJhbWU+XG4gICAgICA8L0Vycm9yQm91bmRhcnk+XG4gICAgKTtcbiAgfVxufVxuXG5QcmV2aWV3UGFuZS5wcm9wVHlwZXMgPSB7XG4gIGNvbGxlY3Rpb246IEltbXV0YWJsZVByb3BUeXBlcy5tYXAuaXNSZXF1aXJlZCxcbiAgZmllbGRzOiBJbW11dGFibGVQcm9wVHlwZXMubGlzdC5pc1JlcXVpcmVkLFxuICBlbnRyeTogSW1tdXRhYmxlUHJvcFR5cGVzLm1hcC5pc1JlcXVpcmVkLFxuICBmaWVsZHNNZXRhRGF0YTogSW1tdXRhYmxlUHJvcFR5cGVzLm1hcC5pc1JlcXVpcmVkLFxuICBnZXRBc3NldDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgb25GaWVsZENsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbn07XG5cbmZ1bmN0aW9uIG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSkge1xuICBjb25zdCBpc0xvYWRpbmdBc3NldCA9IHNlbGVjdElzTG9hZGluZ0Fzc2V0KHN0YXRlLm1lZGlhcyk7XG4gIHJldHVybiB7IGlzTG9hZGluZ0Fzc2V0LCBjb25maWc6IHN0YXRlLmNvbmZpZywgc3RhdGUgfTtcbn1cblxuZnVuY3Rpb24gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoKSB7XG4gIHJldHVybiB7XG4gICAgYm91bmRHZXRBc3NldDogKGNvbGxlY3Rpb24sIGVudHJ5KSA9PiBib3VuZEdldEFzc2V0KGRpc3BhdGNoLCBjb2xsZWN0aW9uLCBlbnRyeSksXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZVByb3BzLFxuICAgIC4uLmRpc3BhdGNoUHJvcHMsXG4gICAgLi4ub3duUHJvcHMsXG4gICAgZ2V0QXNzZXQ6IGRpc3BhdGNoUHJvcHMuYm91bmRHZXRBc3NldChvd25Qcm9wcy5jb2xsZWN0aW9uLCBvd25Qcm9wcy5lbnRyeSksXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMpKFByZXZpZXdQYW5lKTtcbiJdfQ== */"));
const ExternalPreviewIframe = /*#__PURE__*/_styled("iframe", {
  target: "enus48h0",
  label: "ExternalPreviewIframe"
})("width:100%;height:100%;border:none;display:block;background:#fff;border-radius:", lengths.borderRadius, ";" + (process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0VkaXRvci9FZGl0b3JQcmV2aWV3UGFuZS9FZGl0b3JQcmV2aWV3UGFuZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFzQzJDIiwiZmlsZSI6Ii4uLy4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0VkaXRvci9FZGl0b3JQcmV2aWV3UGFuZS9FZGl0b3JQcmV2aWV3UGFuZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHN0eWxlZCBmcm9tICdAZW1vdGlvbi9zdHlsZWQnO1xuaW1wb3J0IHsgTGlzdCwgTWFwIH0gZnJvbSAnaW1tdXRhYmxlJztcbmltcG9ydCBJbW11dGFibGVQcm9wVHlwZXMgZnJvbSAncmVhY3QtaW1tdXRhYmxlLXByb3B0eXBlcyc7XG5pbXBvcnQgRnJhbWUsIHsgRnJhbWVDb250ZXh0Q29uc3VtZXIgfSBmcm9tICdyZWFjdC1mcmFtZS1jb21wb25lbnQnO1xuaW1wb3J0IHsgbGVuZ3RocyB9IGZyb20gJ2RlY2FwLWNtcy11aS1kZWZhdWx0JztcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5cbmltcG9ydCB7IGVuY29kZUVudHJ5IH0gZnJvbSAnLi4vLi4vLi4vbGliL3N0ZWdhJztcbmltcG9ydCB7XG4gIHJlc29sdmVXaWRnZXQsXG4gIGdldFByZXZpZXdUZW1wbGF0ZSxcbiAgZ2V0UHJldmlld1N0eWxlcyxcbiAgZ2V0UmVtYXJrUGx1Z2lucyxcbn0gZnJvbSAnLi4vLi4vLi4vbGliL3JlZ2lzdHJ5JztcbmltcG9ydCB7IGdldEFsbEVudHJpZXMsIHRyeUxvYWRFbnRyeSB9IGZyb20gJy4uLy4uLy4uL2FjdGlvbnMvZW50cmllcyc7XG5pbXBvcnQgeyBFcnJvckJvdW5kYXJ5IH0gZnJvbSAnLi4vLi4vVUknO1xuaW1wb3J0IHtcbiAgc2VsZWN0VGVtcGxhdGVOYW1lLFxuICBzZWxlY3RJbmZlcnJlZEZpZWxkLFxuICBzZWxlY3RGaWVsZCxcbn0gZnJvbSAnLi4vLi4vLi4vcmVkdWNlcnMvY29sbGVjdGlvbnMnO1xuaW1wb3J0IHsgYm91bmRHZXRBc3NldCB9IGZyb20gJy4uLy4uLy4uL2FjdGlvbnMvbWVkaWEnO1xuaW1wb3J0IHsgc2VsZWN0SXNMb2FkaW5nQXNzZXQgfSBmcm9tICcuLi8uLi8uLi9yZWR1Y2Vycy9tZWRpYXMnO1xuaW1wb3J0IHsgSU5GRVJBQkxFX0ZJRUxEUyB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy9maWVsZEluZmVyZW5jZSc7XG5pbXBvcnQgRWRpdG9yUHJldmlld0NvbnRlbnQgZnJvbSAnLi9FZGl0b3JQcmV2aWV3Q29udGVudC5qcyc7XG5pbXBvcnQgUHJldmlld0hPQyBmcm9tICcuL1ByZXZpZXdIT0MnO1xuaW1wb3J0IEVkaXRvclByZXZpZXcgZnJvbSAnLi9FZGl0b3JQcmV2aWV3JztcblxuY29uc3QgUHJldmlld1BhbmVGcmFtZSA9IHN0eWxlZChGcmFtZSlgXG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG4gIGJvcmRlcjogbm9uZTtcbiAgYmFja2dyb3VuZDogI2ZmZjtcbiAgYm9yZGVyLXJhZGl1czogJHtsZW5ndGhzLmJvcmRlclJhZGl1c307XG5gO1xuXG5jb25zdCBFeHRlcm5hbFByZXZpZXdJZnJhbWUgPSBzdHlsZWQuaWZyYW1lYFxuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xuICBib3JkZXI6IG5vbmU7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBiYWNrZ3JvdW5kOiAjZmZmO1xuICBib3JkZXItcmFkaXVzOiAke2xlbmd0aHMuYm9yZGVyUmFkaXVzfTtcbmA7XG5cbmV4cG9ydCBjbGFzcyBQcmV2aWV3UGFuZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGdldFdpZGdldCA9IChmaWVsZCwgdmFsdWUsIG1ldGFkYXRhLCBwcm9wcywgaWR4ID0gbnVsbCkgPT4ge1xuICAgIGNvbnN0IHsgZ2V0QXNzZXQsIGVudHJ5IH0gPSBwcm9wcztcbiAgICBjb25zdCB3aWRnZXQgPSByZXNvbHZlV2lkZ2V0KGZpZWxkLmdldCgnd2lkZ2V0JykpO1xuICAgIGNvbnN0IGtleSA9IGlkeCA/IGZpZWxkLmdldCgnbmFtZScpICsgJ18nICsgaWR4IDogZmllbGQuZ2V0KCduYW1lJyk7XG4gICAgY29uc3QgdmFsdWVJc0luTWFwID0gdmFsdWUgJiYgIXdpZGdldC5hbGxvd01hcFZhbHVlICYmIE1hcC5pc01hcCh2YWx1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBVc2UgYW4gSE9DIHRvIHByb3ZpZGUgY29uZGl0aW9uYWwgdXBkYXRlcyBmb3IgYWxsIHByZXZpZXdzLlxuICAgICAqL1xuICAgIHJldHVybiAhd2lkZ2V0LnByZXZpZXcgPyBudWxsIDogKFxuICAgICAgPFByZXZpZXdIT0NcbiAgICAgICAgcHJldmlld0NvbXBvbmVudD17d2lkZ2V0LnByZXZpZXd9XG4gICAgICAgIGtleT17a2V5fVxuICAgICAgICBmaWVsZD17ZmllbGR9XG4gICAgICAgIGdldEFzc2V0PXtnZXRBc3NldH1cbiAgICAgICAgdmFsdWU9e3ZhbHVlSXNJbk1hcCA/IHZhbHVlLmdldChmaWVsZC5nZXQoJ25hbWUnKSkgOiB2YWx1ZX1cbiAgICAgICAgZW50cnk9e2VudHJ5fVxuICAgICAgICBmaWVsZHNNZXRhRGF0YT17bWV0YWRhdGF9XG4gICAgICAgIHJlc29sdmVXaWRnZXQ9e3Jlc29sdmVXaWRnZXR9XG4gICAgICAgIGdldFJlbWFya1BsdWdpbnM9e2dldFJlbWFya1BsdWdpbnN9XG4gICAgICAvPlxuICAgICk7XG4gIH07XG5cbiAgaW5mZXJyZWRGaWVsZHMgPSB7fTtcblxuICBpbmZlckZpZWxkcygpIHtcbiAgICBjb25zdCB0aXRsZUZpZWxkID0gc2VsZWN0SW5mZXJyZWRGaWVsZCh0aGlzLnByb3BzLmNvbGxlY3Rpb24sICd0aXRsZScpO1xuICAgIGNvbnN0IHNob3J0VGl0bGVGaWVsZCA9IHNlbGVjdEluZmVycmVkRmllbGQodGhpcy5wcm9wcy5jb2xsZWN0aW9uLCAnc2hvcnRUaXRsZScpO1xuICAgIGNvbnN0IGF1dGhvckZpZWxkID0gc2VsZWN0SW5mZXJyZWRGaWVsZCh0aGlzLnByb3BzLmNvbGxlY3Rpb24sICdhdXRob3InKTtcblxuICAgIHRoaXMuaW5mZXJyZWRGaWVsZHMgPSB7fTtcbiAgICBpZiAodGl0bGVGaWVsZCkgdGhpcy5pbmZlcnJlZEZpZWxkc1t0aXRsZUZpZWxkXSA9IElORkVSQUJMRV9GSUVMRFMudGl0bGU7XG4gICAgaWYgKHNob3J0VGl0bGVGaWVsZCkgdGhpcy5pbmZlcnJlZEZpZWxkc1tzaG9ydFRpdGxlRmllbGRdID0gSU5GRVJBQkxFX0ZJRUxEUy5zaG9ydFRpdGxlO1xuICAgIGlmIChhdXRob3JGaWVsZCkgdGhpcy5pbmZlcnJlZEZpZWxkc1thdXRob3JGaWVsZF0gPSBJTkZFUkFCTEVfRklFTERTLmF1dGhvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWRnZXQgY29tcG9uZW50IGZvciBhIG5hbWVkIGZpZWxkLCBhbmQgbWFrZXMgcmVjdXJzaXZlIGNhbGxzXG4gICAqIHRvIHJldHJpZXZlIGNvbXBvbmVudHMgZm9yIG5lc3RlZCBhbmQgZGVlcGx5IG5lc3RlZCBmaWVsZHMsIHdoaWNoIG9jY3VyIGluXG4gICAqIG9iamVjdCBhbmQgbGlzdCB0eXBlIGZpZWxkcy4gVXNlZCBpbnRlcm5hbGx5IHRvIHJldHJpZXZlIHdpZGdldHMsIGFuZCBhbHNvXG4gICAqIGV4cG9zZWQgZm9yIHVzZSBpbiBjdXN0b20gcHJldmlldyB0ZW1wbGF0ZXMuXG4gICAqL1xuICB3aWRnZXRGb3IgPSAoXG4gICAgbmFtZSxcbiAgICBmaWVsZHMgPSB0aGlzLnByb3BzLmZpZWxkcyxcbiAgICB2YWx1ZXMgPSB0aGlzLnByb3BzLmVudHJ5LmdldCgnZGF0YScpLFxuICAgIGZpZWxkc01ldGFEYXRhID0gdGhpcy5wcm9wcy5maWVsZHNNZXRhRGF0YSxcbiAgKSA9PiB7XG4gICAgLy8gV2UgcmV0cmlldmUgdGhlIGZpZWxkIGJ5IG5hbWUgc28gdGhhdCB0aGlzIGZ1bmN0aW9uIGNhbiBhbHNvIGJlIHVzZWQgaW5cbiAgICAvLyBjdXN0b20gcHJldmlldyB0ZW1wbGF0ZXMsIHdoZXJlIHRoZSBmaWVsZCBvYmplY3QgY2FuJ3QgYmUgcGFzc2VkIGluLlxuICAgIGxldCBmaWVsZCA9IGZpZWxkcyAmJiBmaWVsZHMuZmluZChmID0+IGYuZ2V0KCduYW1lJykgPT09IG5hbWUpO1xuICAgIGxldCB2YWx1ZSA9IE1hcC5pc01hcCh2YWx1ZXMpICYmIHZhbHVlcy5nZXQoZmllbGQuZ2V0KCduYW1lJykpO1xuICAgIGlmIChmaWVsZC5nZXQoJ21ldGEnKSkge1xuICAgICAgdmFsdWUgPSB0aGlzLnByb3BzLmVudHJ5LmdldEluKFsnbWV0YScsIGZpZWxkLmdldCgnbmFtZScpXSk7XG4gICAgfVxuXG4gICAgY29uc3QgbmVzdGVkRmllbGRzID0gZmllbGQuZ2V0KCdmaWVsZHMnKTtcbiAgICBjb25zdCBzaW5nbGVGaWVsZCA9IGZpZWxkLmdldCgnZmllbGQnKTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGZpZWxkc01ldGFEYXRhICYmIGZpZWxkc01ldGFEYXRhLmdldChmaWVsZC5nZXQoJ25hbWUnKSwgTWFwKCkpO1xuXG4gICAgaWYgKG5lc3RlZEZpZWxkcykge1xuICAgICAgZmllbGQgPSBmaWVsZC5zZXQoJ2ZpZWxkcycsIHRoaXMuZ2V0TmVzdGVkV2lkZ2V0cyhuZXN0ZWRGaWVsZHMsIHZhbHVlLCBtZXRhZGF0YSkpO1xuICAgIH1cblxuICAgIGlmIChzaW5nbGVGaWVsZCkge1xuICAgICAgZmllbGQgPSBmaWVsZC5zZXQoJ2ZpZWxkJywgdGhpcy5nZXRTaW5nbGVOZXN0ZWQoc2luZ2xlRmllbGQsIHZhbHVlLCBtZXRhZGF0YSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVsbGVkV2lkZ2V0cyA9IFsnc3RyaW5nJywgJ3RleHQnLCAnbnVtYmVyJ107XG4gICAgY29uc3QgaW5mZXJyZWRGaWVsZCA9IE9iamVjdC5lbnRyaWVzKHRoaXMuaW5mZXJyZWRGaWVsZHMpXG4gICAgICAuZmlsdGVyKChba2V5XSkgPT4ge1xuICAgICAgICBjb25zdCBmaWVsZFRvTWF0Y2ggPSBzZWxlY3RGaWVsZCh0aGlzLnByb3BzLmNvbGxlY3Rpb24sIGtleSk7XG4gICAgICAgIHJldHVybiBmaWVsZFRvTWF0Y2ggPT09IGZpZWxkO1xuICAgICAgfSlcbiAgICAgIC5tYXAoKFssIHZhbHVlXSkgPT4gdmFsdWUpWzBdO1xuXG4gICAgaWYgKGluZmVycmVkRmllbGQpIHtcbiAgICAgIHZhbHVlID0gaW5mZXJyZWRGaWVsZC5kZWZhdWx0UHJldmlldyh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHZhbHVlICYmXG4gICAgICBsYWJlbGxlZFdpZGdldHMuaW5kZXhPZihmaWVsZC5nZXQoJ3dpZGdldCcpKSAhPT0gLTEgJiZcbiAgICAgIHZhbHVlLnRvU3RyaW5nKCkubGVuZ3RoIDwgNTBcbiAgICApIHtcbiAgICAgIHZhbHVlID0gKFxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxzdHJvbmc+e2ZpZWxkLmdldCgnbGFiZWwnLCBmaWVsZC5nZXQoJ25hbWUnKSl9Ojwvc3Ryb25nPiB7dmFsdWV9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUgPyB0aGlzLmdldFdpZGdldChmaWVsZCwgdmFsdWUsIG1ldGFkYXRhLCB0aGlzLnByb3BzKSA6IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB3aWRnZXRzIGZvciBuZXN0ZWQgZmllbGRzIChjaGlsZHJlbiBvZiBvYmplY3QvbGlzdCBmaWVsZHMpXG4gICAqL1xuICBnZXROZXN0ZWRXaWRnZXRzID0gKGZpZWxkcywgdmFsdWVzLCBmaWVsZHNNZXRhRGF0YSkgPT4ge1xuICAgIC8vIEZpZWxkcyBuZXN0ZWQgd2l0aGluIGEgbGlzdCBmaWVsZCB3aWxsIGJlIHBhaXJlZCB3aXRoIGEgTGlzdCBvZiB2YWx1ZSBNYXBzLlxuICAgIGlmIChMaXN0LmlzTGlzdCh2YWx1ZXMpKSB7XG4gICAgICByZXR1cm4gdmFsdWVzLm1hcCh2YWx1ZSA9PiB0aGlzLndpZGdldHNGb3JOZXN0ZWRGaWVsZHMoZmllbGRzLCB2YWx1ZSwgZmllbGRzTWV0YURhdGEpKTtcbiAgICB9XG4gICAgLy8gRmllbGRzIG5lc3RlZCB3aXRoaW4gYW4gb2JqZWN0IGZpZWxkIHdpbGwgYmUgcGFpcmVkIHdpdGggYSBzaW5nbGUgTWFwIG9mIHZhbHVlcy5cbiAgICByZXR1cm4gdGhpcy53aWRnZXRzRm9yTmVzdGVkRmllbGRzKGZpZWxkcywgdmFsdWVzLCBmaWVsZHNNZXRhRGF0YSk7XG4gIH07XG5cbiAgZ2V0U2luZ2xlTmVzdGVkID0gKGZpZWxkLCB2YWx1ZXMsIGZpZWxkc01ldGFEYXRhKSA9PiB7XG4gICAgaWYgKExpc3QuaXNMaXN0KHZhbHVlcykpIHtcbiAgICAgIHJldHVybiB2YWx1ZXMubWFwKCh2YWx1ZSwgaWR4KSA9PlxuICAgICAgICB0aGlzLmdldFdpZGdldChmaWVsZCwgdmFsdWUsIGZpZWxkc01ldGFEYXRhLmdldChmaWVsZC5nZXQoJ25hbWUnKSksIHRoaXMucHJvcHMsIGlkeCksXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRXaWRnZXQoZmllbGQsIHZhbHVlcywgZmllbGRzTWV0YURhdGEuZ2V0KGZpZWxkLmdldCgnbmFtZScpKSwgdGhpcy5wcm9wcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVzZSB3aWRnZXRGb3IgYXMgYSBtYXBwaW5nIGZ1bmN0aW9uIGZvciByZWN1cnNpdmUgd2lkZ2V0IHJldHJpZXZhbFxuICAgKi9cbiAgd2lkZ2V0c0Zvck5lc3RlZEZpZWxkcyA9IChmaWVsZHMsIHZhbHVlcywgZmllbGRzTWV0YURhdGEpID0+IHtcbiAgICByZXR1cm4gZmllbGRzLm1hcChmaWVsZCA9PiB0aGlzLndpZGdldEZvcihmaWVsZC5nZXQoJ25hbWUnKSwgZmllbGRzLCB2YWx1ZXMsIGZpZWxkc01ldGFEYXRhKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gZXhpc3RzIGVudGlyZWx5IHRvIGV4cG9zZSBuZXN0ZWQgd2lkZ2V0cyBmb3Igb2JqZWN0IGFuZCBsaXN0XG4gICAqIGZpZWxkcyB0byBjdXN0b20gcHJldmlldyB0ZW1wbGF0ZXMuXG4gICAqXG4gICAqIFRPRE86IHNlZSBpZiB3aWRnZXRGb3IgY2FuIG5vdyBwcm92aWRlIHRoaXMgZnVuY3Rpb25hbGl0eSBmb3IgcHJldmlldyB0ZW1wbGF0ZXNcbiAgICovXG4gIHdpZGdldHNGb3IgPSBuYW1lID0+IHtcbiAgICBjb25zdCB7IGZpZWxkcywgZW50cnksIGZpZWxkc01ldGFEYXRhIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGZpZWxkID0gZmllbGRzLmZpbmQoZiA9PiBmLmdldCgnbmFtZScpID09PSBuYW1lKTtcbiAgICBjb25zdCBuZXN0ZWRGaWVsZHMgPSBmaWVsZCAmJiBmaWVsZC5nZXQoJ2ZpZWxkcycpO1xuICAgIGNvbnN0IHZhcmlhYmxlVHlwZXMgPSBmaWVsZCAmJiBmaWVsZC5nZXQoJ3R5cGVzJyk7XG4gICAgY29uc3QgdmFsdWUgPSBlbnRyeS5nZXRJbihbJ2RhdGEnLCBmaWVsZC5nZXQoJ25hbWUnKV0pO1xuICAgIGNvbnN0IG1ldGFkYXRhID0gZmllbGRzTWV0YURhdGEuZ2V0KGZpZWxkLmdldCgnbmFtZScpLCBNYXAoKSk7XG5cbiAgICAvLyBWYXJpYWJsZSBUeXBlIGxpc3RzXG4gICAgaWYgKExpc3QuaXNMaXN0KHZhbHVlKSAmJiB2YXJpYWJsZVR5cGVzKSB7XG4gICAgICByZXR1cm4gdmFsdWUubWFwKHZhbCA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHZhcmlhYmxlVHlwZXMuZmluZCh0ID0+IHQuZ2V0KCduYW1lJykgPT09IHZhbC5nZXQoJ3R5cGUnKSk7XG4gICAgICAgIGNvbnN0IHR5cGVGaWVsZHMgPSB2YWx1ZVR5cGUgJiYgdmFsdWVUeXBlLmdldCgnZmllbGRzJyk7XG4gICAgICAgIGNvbnN0IHdpZGdldHMgPVxuICAgICAgICAgIHR5cGVGaWVsZHMgJiZcbiAgICAgICAgICBNYXAoXG4gICAgICAgICAgICB0eXBlRmllbGRzLm1hcCgoZiwgaSkgPT4gW1xuICAgICAgICAgICAgICBmLmdldCgnbmFtZScpLFxuICAgICAgICAgICAgICA8ZGl2IGtleT17aX0+e3RoaXMuZ2V0V2lkZ2V0KGYsIHZhbCwgbWV0YWRhdGEuZ2V0KGYuZ2V0KCduYW1lJykpLCB0aGlzLnByb3BzKX08L2Rpdj4sXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gTWFwKHsgZGF0YTogdmFsLCB3aWRnZXRzIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gTGlzdCB3aWRnZXRzXG4gICAgaWYgKExpc3QuaXNMaXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLm1hcCh2YWwgPT4ge1xuICAgICAgICBjb25zdCB3aWRnZXRzID1cbiAgICAgICAgICBuZXN0ZWRGaWVsZHMgJiZcbiAgICAgICAgICBNYXAoXG4gICAgICAgICAgICBuZXN0ZWRGaWVsZHMubWFwKChmLCBpKSA9PiBbXG4gICAgICAgICAgICAgIGYuZ2V0KCduYW1lJyksXG4gICAgICAgICAgICAgIDxkaXYga2V5PXtpfT57dGhpcy5nZXRXaWRnZXQoZiwgdmFsLCBtZXRhZGF0YS5nZXQoZi5nZXQoJ25hbWUnKSksIHRoaXMucHJvcHMpfTwvZGl2PixcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiBNYXAoeyBkYXRhOiB2YWwsIHdpZGdldHMgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gTWFwKHtcbiAgICAgIGRhdGE6IHZhbHVlLFxuICAgICAgd2lkZ2V0czpcbiAgICAgICAgbmVzdGVkRmllbGRzICYmXG4gICAgICAgIE1hcChcbiAgICAgICAgICBuZXN0ZWRGaWVsZHMubWFwKGYgPT4gW1xuICAgICAgICAgICAgZi5nZXQoJ25hbWUnKSxcbiAgICAgICAgICAgIHRoaXMuZ2V0V2lkZ2V0KGYsIHZhbHVlLCBtZXRhZGF0YS5nZXQoZi5nZXQoJ25hbWUnKSksIHRoaXMucHJvcHMpLFxuICAgICAgICAgIF0pLFxuICAgICAgICApLFxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGV4aXN0cyBlbnRpcmVseSB0byBleHBvc2UgY29sbGVjdGlvbnMgZnJvbSBvdXRzaWRlIG9mIHRoaXMgZW50cnlcbiAgICpcbiAgICovXG4gIGdldENvbGxlY3Rpb24gPSBhc3luYyAoY29sbGVjdGlvbk5hbWUsIHNsdWcpID0+IHtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHNlbGVjdGVkQ29sbGVjdGlvbiA9IHN0YXRlLmNvbGxlY3Rpb25zLmdldChjb2xsZWN0aW9uTmFtZSk7XG5cbiAgICBpZiAodHlwZW9mIHNsdWcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgZ2V0QWxsRW50cmllcyhzdGF0ZSwgc2VsZWN0ZWRDb2xsZWN0aW9uKTtcbiAgICAgIHJldHVybiBlbnRyaWVzLm1hcChlbnRyeSA9PiBNYXAoKS5zZXQoJ2RhdGEnLCBlbnRyeS5kYXRhKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZW50cnkgPSBhd2FpdCB0cnlMb2FkRW50cnkoc3RhdGUsIHNlbGVjdGVkQ29sbGVjdGlvbiwgc2x1Zyk7XG4gICAgcmV0dXJuIE1hcCgpLnNldCgnZGF0YScsIGVudHJ5LmRhdGEpO1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGVudHJ5LCBjb2xsZWN0aW9uLCBjb25maWcgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoIWVudHJ5IHx8ICFlbnRyeS5nZXQoJ2RhdGEnKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgcHJldmlld0NvbXBvbmVudCA9XG4gICAgICBnZXRQcmV2aWV3VGVtcGxhdGUoc2VsZWN0VGVtcGxhdGVOYW1lKGNvbGxlY3Rpb24sIGVudHJ5LmdldCgnc2x1ZycpKSkgfHwgRWRpdG9yUHJldmlldztcblxuICAgIHRoaXMuaW5mZXJGaWVsZHMoKTtcblxuICAgIGNvbnN0IHZpc3VhbEVkaXRpbmcgPSBjb2xsZWN0aW9uLmdldEluKFsnZWRpdG9yJywgJ3Zpc3VhbEVkaXRpbmcnXSwgZmFsc2UpO1xuXG4gICAgLy8gT25seSBlbmNvZGUgZW50cnkgZGF0YSBpZiB2aXN1YWwgZWRpdGluZyBpcyBlbmFibGVkXG4gICAgY29uc3QgcHJldmlld0VudHJ5ID0gdmlzdWFsRWRpdGluZ1xuICAgICAgPyBlbnRyeS5zZXQoJ2RhdGEnLCBlbmNvZGVFbnRyeShlbnRyeS5nZXQoJ2RhdGEnKSwgdGhpcy5wcm9wcy5maWVsZHMpKVxuICAgICAgOiBlbnRyeTtcblxuICAgIGNvbnN0IHByZXZpZXdQcm9wcyA9IHtcbiAgICAgIC4uLnRoaXMucHJvcHMsXG4gICAgICBlbnRyeTogcHJldmlld0VudHJ5LFxuICAgICAgd2lkZ2V0Rm9yOiAobmFtZSwgZmllbGRzLCB2YWx1ZXMgPSBwcmV2aWV3RW50cnkuZ2V0KCdkYXRhJyksIGZpZWxkc01ldGFEYXRhKSA9PlxuICAgICAgICB0aGlzLndpZGdldEZvcihuYW1lLCBmaWVsZHMsIHZhbHVlcywgZmllbGRzTWV0YURhdGEpLFxuICAgICAgd2lkZ2V0c0ZvcjogdGhpcy53aWRnZXRzRm9yLFxuICAgICAgZ2V0Q29sbGVjdGlvbjogdGhpcy5nZXRDb2xsZWN0aW9uLFxuICAgIH07XG5cbiAgICBjb25zdCBzdHlsZUVscyA9IGdldFByZXZpZXdTdHlsZXMoKS5tYXAoKHN0eWxlLCBpKSA9PiB7XG4gICAgICBpZiAoc3R5bGUucmF3KSB7XG4gICAgICAgIHJldHVybiA8c3R5bGUga2V5PXtpfT57c3R5bGUudmFsdWV9PC9zdHlsZT47XG4gICAgICB9XG4gICAgICByZXR1cm4gPGxpbmsga2V5PXtpfSBocmVmPXtzdHlsZS52YWx1ZX0gdHlwZT1cInRleHQvY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiIC8+O1xuICAgIH0pO1xuXG4gICAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgICA8UHJldmlld1BhbmVGcmFtZSBpZD1cInByZXZpZXctcGFuZVwiIGhlYWQ9e3N0eWxlRWxzfSAvPjtcbiAgICB9XG5cbiAgICAvLyBGb3IgbG9jYWwgcHJldmlldyBtaXJyb3IgKG9yIGxlZ2FjeSBsb2NhbF9iYWNrZW5kKSwgcmVuZGVyIHRoZSByZWFsIEh1Z28gcGFnZSB2aWEgaWZyYW1lXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGlzTWlycm9yUHJldmlldyA9ICEhKGNvbmZpZyAmJiAoY29uZmlnLmxvY2FsX3ByZXZpZXdfbWlycm9yIHx8IGNvbmZpZy5sb2NhbF9iYWNrZW5kKSk7XG4gICAgICBpZiAoaXNNaXJyb3JQcmV2aWV3KSB7XG4gICAgICAgIGNvbnN0IGZvbGRlciA9IChjb2xsZWN0aW9uLmdldCgnZm9sZGVyJykgfHwgJycpLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIHNlY3Rpb24gZGVyaXZlZCBmcm9tIGZvbGRlciwgZS5nLiwgY29udGVudC90ZWNoLXN0YWNrIC0+IHRlY2gtc3RhY2tcbiAgICAgICAgY29uc3Qgc2VjdGlvbiA9IGZvbGRlci5yZXBsYWNlKC9eXFwvP2NvbnRlbnRcXC8/L2ksICcnKS5yZXBsYWNlKC9eXFwvK3xcXC8rJC9nLCAnJyk7XG4gICAgICAgIGNvbnN0IHNsdWcgPSAoKGVudHJ5LmdldCgnc2x1ZycpIHx8ICcnKS50b1N0cmluZygpKS5yZXBsYWNlKC9eXFwvK3xcXC8rJC9nLCAnJyk7XG4gICAgICAgIGNvbnN0IG5lZWRzU2VjdGlvbiA9IHNlY3Rpb24gJiYgIXNsdWcuc3RhcnRzV2l0aChgJHtzZWN0aW9ufS9gKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IG5lZWRzU2VjdGlvbiA/IGAke3NlY3Rpb259LyR7c2x1Z31gIDogc2x1ZztcbiAgICAgICAgY29uc3QgYmFzZSA9XG4gICAgICAgICAgKGNvbmZpZyAmJiAoY29uZmlnLmdldCAmJiAoY29uZmlnLmdldCgnZGlzcGxheV91cmwnKSB8fCBjb25maWcuZ2V0KCdzaXRlX3VybCcpKSkpIHx8XG4gICAgICAgICAgKGNvbmZpZyAmJiAoKGNvbmZpZy5kaXNwbGF5X3VybCkgfHwgKGNvbmZpZy5zaXRlX3VybCkpKSB8fFxuICAgICAgICAgICgodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pIHx8ICcnKTtcbiAgICAgICAgbGV0IHByZXZpZXdVcmwgPSBgJHtiYXNlfS8ke3BhdGgucmVwbGFjZSgvXlxcLyt8XFwvKyR8XFwvXFwvKyQvZywgJycpfS9gO1xuICAgICAgICAvLyBTdHJpcCB0cmFpbGluZyAnL2luZGV4JyBvciAnL2luZGV4LycgZnJvbSBuZXN0ZWQgaW5kZXgubWQgVVJMc1xuICAgICAgICBwcmV2aWV3VXJsID0gcHJldmlld1VybC5yZXBsYWNlKC9cXC8oaW5kZXhcXC8/KSg/PSR8XFw/KS9pLCAnLycpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUpIHtcbiAgICAgICAgICB0cnkgeyBjb25zb2xlLmxvZygnW2xvY2FsX3ByZXZpZXdfbWlycm9yIHByZXZpZXddIHVybDonLCB7IHNlY3Rpb24sIHNsdWcsIHBhdGgsIHByZXZpZXdVcmwgfSk7IH0gY2F0Y2ggKF8pIHt9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGhlaWdodDogJzEwMCUnLCBkaXNwbGF5OiAnZmxleCcsIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nIH19PlxuICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBwYWRkaW5nOiAnNnB4IDhweCcsIGJvcmRlckJvdHRvbTogJzFweCBzb2xpZCAjZTFlNGU4JywgYmFja2dyb3VuZDogJyNmYWZiZmMnLCBmb250U2l6ZTogMTIgfX0+XG4gICAgICAgICAgICAgIDxzcGFuIHN0eWxlPXt7IG1hcmdpblJpZ2h0OiA4LCB3b3JkQnJlYWs6ICdicmVhay1hbGwnIH19PntwcmV2aWV3VXJsfTwvc3Bhbj5cbiAgICAgICAgICAgICAgPGEgaHJlZj17cHJldmlld1VybH0gdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiIHN0eWxlPXt7IHRleHREZWNvcmF0aW9uOiAnbm9uZScsIGNvbG9yOiAnIzA5NjlkYScgfX0+T3BlbiBpbiBuZXcgdGFiPC9hPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGZsZXg6IDEsIG1pbkhlaWdodDogMCB9fT5cbiAgICAgICAgICAgICAgPEV4dGVybmFsUHJldmlld0lmcmFtZVxuICAgICAgICAgICAgICAgIGlkPVwiaHVnby1leHRlcm5hbC1wcmV2aWV3LWlmcmFtZVwiXG4gICAgICAgICAgICAgICAgc3JjPXtwcmV2aWV3VXJsfVxuICAgICAgICAgICAgICAgIG9uRXJyb3I9eygpID0+IHdpbmRvdy5hbGVydCgnUHJldmlldyBmYWlsZWQgdG8gbG9hZC4gSXMgdGhlIEh1Z28gc2VydmVyIHJ1bm5pbmc/Jyl9XG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScgfX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGZhbGwgYmFjayB0byBkZWZhdWx0IGJlbG93XG4gICAgfVxuXG4gICAgY29uc3QgaW5pdGlhbENvbnRlbnQgPSBgXG48IURPQ1RZUEUgaHRtbD5cbjxodG1sPlxuICA8aGVhZD48YmFzZSB0YXJnZXQ9XCJfYmxhbmtcIi8+PC9oZWFkPlxuICA8Ym9keT48ZGl2PjwvZGl2PjwvYm9keT5cbjwvaHRtbD5cbmA7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEVycm9yQm91bmRhcnkgY29uZmlnPXtjb25maWd9PlxuICAgICAgICA8UHJldmlld1BhbmVGcmFtZSBpZD1cInByZXZpZXctcGFuZVwiIGhlYWQ9e3N0eWxlRWxzfSBpbml0aWFsQ29udGVudD17aW5pdGlhbENvbnRlbnR9PlxuICAgICAgICAgIDxGcmFtZUNvbnRleHRDb25zdW1lcj5cbiAgICAgICAgICAgIHsoeyBkb2N1bWVudCwgd2luZG93IH0pID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8RWRpdG9yUHJldmlld0NvbnRlbnRcbiAgICAgICAgICAgICAgICAgIHsuLi57IHByZXZpZXdDb21wb25lbnQsIHByZXZpZXdQcm9wczogeyAuLi5wcmV2aWV3UHJvcHMsIGRvY3VtZW50LCB3aW5kb3cgfSB9fVxuICAgICAgICAgICAgICAgICAgb25GaWVsZENsaWNrPXt0aGlzLnByb3BzLm9uRmllbGRDbGlja31cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICA8L0ZyYW1lQ29udGV4dENvbnN1bWVyPlxuICAgICAgICA8L1ByZXZpZXdQYW5lRnJhbWU+XG4gICAgICA8L0Vycm9yQm91bmRhcnk+XG4gICAgKTtcbiAgfVxufVxuXG5QcmV2aWV3UGFuZS5wcm9wVHlwZXMgPSB7XG4gIGNvbGxlY3Rpb246IEltbXV0YWJsZVByb3BUeXBlcy5tYXAuaXNSZXF1aXJlZCxcbiAgZmllbGRzOiBJbW11dGFibGVQcm9wVHlwZXMubGlzdC5pc1JlcXVpcmVkLFxuICBlbnRyeTogSW1tdXRhYmxlUHJvcFR5cGVzLm1hcC5pc1JlcXVpcmVkLFxuICBmaWVsZHNNZXRhRGF0YTogSW1tdXRhYmxlUHJvcFR5cGVzLm1hcC5pc1JlcXVpcmVkLFxuICBnZXRBc3NldDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgb25GaWVsZENsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbn07XG5cbmZ1bmN0aW9uIG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSkge1xuICBjb25zdCBpc0xvYWRpbmdBc3NldCA9IHNlbGVjdElzTG9hZGluZ0Fzc2V0KHN0YXRlLm1lZGlhcyk7XG4gIHJldHVybiB7IGlzTG9hZGluZ0Fzc2V0LCBjb25maWc6IHN0YXRlLmNvbmZpZywgc3RhdGUgfTtcbn1cblxuZnVuY3Rpb24gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoKSB7XG4gIHJldHVybiB7XG4gICAgYm91bmRHZXRBc3NldDogKGNvbGxlY3Rpb24sIGVudHJ5KSA9PiBib3VuZEdldEFzc2V0KGRpc3BhdGNoLCBjb2xsZWN0aW9uLCBlbnRyeSksXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZVByb3BzLFxuICAgIC4uLmRpc3BhdGNoUHJvcHMsXG4gICAgLi4ub3duUHJvcHMsXG4gICAgZ2V0QXNzZXQ6IGRpc3BhdGNoUHJvcHMuYm91bmRHZXRBc3NldChvd25Qcm9wcy5jb2xsZWN0aW9uLCBvd25Qcm9wcy5lbnRyeSksXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMpKFByZXZpZXdQYW5lKTtcbiJdfQ== */"));
export class PreviewPane extends React.Component {
  getWidget = (field, value, metadata, props, idx = null) => {
    const {
      getAsset,
      entry
    } = props;
    const widget = resolveWidget(field.get('widget'));
    const key = idx ? field.get('name') + '_' + idx : field.get('name');
    const valueIsInMap = value && !widget.allowMapValue && Map.isMap(value);

    /**
     * Use an HOC to provide conditional updates for all previews.
     */
    return !widget.preview ? null : ___EmotionJSX(PreviewHOC, {
      previewComponent: widget.preview,
      key: key,
      field: field,
      getAsset: getAsset,
      value: valueIsInMap ? value.get(field.get('name')) : value,
      entry: entry,
      fieldsMetaData: metadata,
      resolveWidget: resolveWidget,
      getRemarkPlugins: getRemarkPlugins
    });
  };
  inferredFields = {};
  inferFields() {
    const titleField = selectInferredField(this.props.collection, 'title');
    const shortTitleField = selectInferredField(this.props.collection, 'shortTitle');
    const authorField = selectInferredField(this.props.collection, 'author');
    this.inferredFields = {};
    if (titleField) this.inferredFields[titleField] = INFERABLE_FIELDS.title;
    if (shortTitleField) this.inferredFields[shortTitleField] = INFERABLE_FIELDS.shortTitle;
    if (authorField) this.inferredFields[authorField] = INFERABLE_FIELDS.author;
  }

  /**
   * Returns the widget component for a named field, and makes recursive calls
   * to retrieve components for nested and deeply nested fields, which occur in
   * object and list type fields. Used internally to retrieve widgets, and also
   * exposed for use in custom preview templates.
   */
  widgetFor = (name, fields = this.props.fields, values = this.props.entry.get('data'), fieldsMetaData = this.props.fieldsMetaData) => {
    // We retrieve the field by name so that this function can also be used in
    // custom preview templates, where the field object can't be passed in.
    let field = fields && fields.find(f => f.get('name') === name);
    let value = Map.isMap(values) && values.get(field.get('name'));
    if (field.get('meta')) {
      value = this.props.entry.getIn(['meta', field.get('name')]);
    }
    const nestedFields = field.get('fields');
    const singleField = field.get('field');
    const metadata = fieldsMetaData && fieldsMetaData.get(field.get('name'), Map());
    if (nestedFields) {
      field = field.set('fields', this.getNestedWidgets(nestedFields, value, metadata));
    }
    if (singleField) {
      field = field.set('field', this.getSingleNested(singleField, value, metadata));
    }
    const labelledWidgets = ['string', 'text', 'number'];
    const inferredField = Object.entries(this.inferredFields).filter(([key]) => {
      const fieldToMatch = selectField(this.props.collection, key);
      return fieldToMatch === field;
    }).map(([, value]) => value)[0];
    if (inferredField) {
      value = inferredField.defaultPreview(value);
    } else if (value && labelledWidgets.indexOf(field.get('widget')) !== -1 && value.toString().length < 50) {
      value = ___EmotionJSX("div", null, ___EmotionJSX("strong", null, field.get('label', field.get('name')), ":"), " ", value);
    }
    return value ? this.getWidget(field, value, metadata, this.props) : null;
  };

  /**
   * Retrieves widgets for nested fields (children of object/list fields)
   */
  getNestedWidgets = (fields, values, fieldsMetaData) => {
    // Fields nested within a list field will be paired with a List of value Maps.
    if (List.isList(values)) {
      return values.map(value => this.widgetsForNestedFields(fields, value, fieldsMetaData));
    }
    // Fields nested within an object field will be paired with a single Map of values.
    return this.widgetsForNestedFields(fields, values, fieldsMetaData);
  };
  getSingleNested = (field, values, fieldsMetaData) => {
    if (List.isList(values)) {
      return values.map((value, idx) => this.getWidget(field, value, fieldsMetaData.get(field.get('name')), this.props, idx));
    }
    return this.getWidget(field, values, fieldsMetaData.get(field.get('name')), this.props);
  };

  /**
   * Use widgetFor as a mapping function for recursive widget retrieval
   */
  widgetsForNestedFields = (fields, values, fieldsMetaData) => {
    return fields.map(field => this.widgetFor(field.get('name'), fields, values, fieldsMetaData));
  };

  /**
   * This function exists entirely to expose nested widgets for object and list
   * fields to custom preview templates.
   *
   * TODO: see if widgetFor can now provide this functionality for preview templates
   */
  widgetsFor = name => {
    const {
      fields,
      entry,
      fieldsMetaData
    } = this.props;
    const field = fields.find(f => f.get('name') === name);
    const nestedFields = field && field.get('fields');
    const variableTypes = field && field.get('types');
    const value = entry.getIn(['data', field.get('name')]);
    const metadata = fieldsMetaData.get(field.get('name'), Map());

    // Variable Type lists
    if (List.isList(value) && variableTypes) {
      return value.map(val => {
        const valueType = variableTypes.find(t => t.get('name') === val.get('type'));
        const typeFields = valueType && valueType.get('fields');
        const widgets = typeFields && Map(typeFields.map((f, i) => [f.get('name'), ___EmotionJSX("div", {
          key: i
        }, this.getWidget(f, val, metadata.get(f.get('name')), this.props))]));
        return Map({
          data: val,
          widgets
        });
      });
    }

    // List widgets
    if (List.isList(value)) {
      return value.map(val => {
        const widgets = nestedFields && Map(nestedFields.map((f, i) => [f.get('name'), ___EmotionJSX("div", {
          key: i
        }, this.getWidget(f, val, metadata.get(f.get('name')), this.props))]));
        return Map({
          data: val,
          widgets
        });
      });
    }
    return Map({
      data: value,
      widgets: nestedFields && Map(nestedFields.map(f => [f.get('name'), this.getWidget(f, value, metadata.get(f.get('name')), this.props)]))
    });
  };

  /**
   * This function exists entirely to expose collections from outside of this entry
   *
   */
  getCollection = async (collectionName, slug) => {
    const {
      state
    } = this.props;
    const selectedCollection = state.collections.get(collectionName);
    if (typeof slug === 'undefined') {
      const entries = await getAllEntries(state, selectedCollection);
      return entries.map(entry => Map().set('data', entry.data));
    }
    const entry = await tryLoadEntry(state, selectedCollection, slug);
    return Map().set('data', entry.data);
  };
  render() {
    const {
      entry,
      collection,
      config
    } = this.props;
    if (!entry || !entry.get('data')) {
      return null;
    }
    const previewComponent = getPreviewTemplate(selectTemplateName(collection, entry.get('slug'))) || EditorPreview;
    this.inferFields();
    const visualEditing = collection.getIn(['editor', 'visualEditing'], false);

    // Only encode entry data if visual editing is enabled
    const previewEntry = visualEditing ? entry.set('data', encodeEntry(entry.get('data'), this.props.fields)) : entry;
    const previewProps = {
      ...this.props,
      entry: previewEntry,
      widgetFor: (name, fields, values = previewEntry.get('data'), fieldsMetaData) => this.widgetFor(name, fields, values, fieldsMetaData),
      widgetsFor: this.widgetsFor,
      getCollection: this.getCollection
    };
    const styleEls = getPreviewStyles().map((style, i) => {
      if (style.raw) {
        return ___EmotionJSX("style", {
          key: i
        }, style.value);
      }
      return ___EmotionJSX("link", {
        key: i,
        href: style.value,
        type: "text/css",
        rel: "stylesheet"
      });
    });
    if (!collection) {
      ___EmotionJSX(PreviewPaneFrame, {
        id: "preview-pane",
        head: styleEls
      });
    }

    // For local preview mirror (or legacy local_backend), render the real Hugo page via iframe
    try {
      const isMirrorPreview = !!(config && (config.local_preview_mirror || config.local_backend));
      if (isMirrorPreview) {
        const folder = (collection.get('folder') || '').toString();
        // section derived from folder, e.g., content/tech-stack -> tech-stack
        const section = folder.replace(/^\/?content\/?/i, '').replace(/^\/+|\/+$/g, '');
        const slug = (entry.get('slug') || '').toString().replace(/^\/+|\/+$/g, '');
        const needsSection = section && !slug.startsWith(`${section}/`);
        const path = needsSection ? `${section}/${slug}` : slug;
        const base = config && config.get && (config.get('display_url') || config.get('site_url')) || config && (config.display_url || config.site_url) || typeof window !== 'undefined' && window.location && window.location.origin || '';
        let previewUrl = `${base}/${path.replace(/^\/+|\/+$|\/\/+$/g, '')}/`;
        // Strip trailing '/index' or '/index/' from nested index.md URLs
        previewUrl = previewUrl.replace(/\/(index\/?)(?=$|\?)/i, '/');
        if (typeof window !== 'undefined' && window.console) {
          try {
            console.log('[local_preview_mirror preview] url:', {
              section,
              slug,
              path,
              previewUrl
            });
          } catch (_) {}
        }
        return ___EmotionJSX("div", {
          style: {
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }
        }, ___EmotionJSX("div", {
          style: {
            padding: '6px 8px',
            borderBottom: '1px solid #e1e4e8',
            background: '#fafbfc',
            fontSize: 12
          }
        }, ___EmotionJSX("span", {
          style: {
            marginRight: 8,
            wordBreak: 'break-all'
          }
        }, previewUrl), ___EmotionJSX("a", {
          href: previewUrl,
          target: "_blank",
          rel: "noopener noreferrer",
          style: {
            textDecoration: 'none',
            color: '#0969da'
          }
        }, "Open in new tab")), ___EmotionJSX("div", {
          style: {
            flex: 1,
            minHeight: 0
          }
        }, ___EmotionJSX(ExternalPreviewIframe, {
          id: "hugo-external-preview-iframe",
          src: previewUrl,
          onError: () => window.alert('Preview failed to load. Is the Hugo server running?'),
          style: {
            width: '100%',
            height: '100%'
          }
        })));
      }
    } catch (e) {
      // fall back to default below
    }
    const initialContent = `
<!DOCTYPE html>
<html>
  <head><base target="_blank"/></head>
  <body><div></div></body>
</html>
`;
    return ___EmotionJSX(ErrorBoundary, {
      config: config
    }, ___EmotionJSX(PreviewPaneFrame, {
      id: "preview-pane",
      head: styleEls,
      initialContent: initialContent
    }, ___EmotionJSX(FrameContextConsumer, null, ({
      document,
      window
    }) => {
      return ___EmotionJSX(EditorPreviewContent, {
        previewComponent,
        previewProps: {
          ...previewProps,
          document,
          window
        },
        onFieldClick: this.props.onFieldClick
      });
    })));
  }
}
PreviewPane.propTypes = {
  collection: ImmutablePropTypes.map.isRequired,
  fields: ImmutablePropTypes.list.isRequired,
  entry: ImmutablePropTypes.map.isRequired,
  fieldsMetaData: ImmutablePropTypes.map.isRequired,
  getAsset: PropTypes.func.isRequired,
  onFieldClick: PropTypes.func
};
function mapStateToProps(state) {
  const isLoadingAsset = selectIsLoadingAsset(state.medias);
  return {
    isLoadingAsset,
    config: state.config,
    state
  };
}
function mapDispatchToProps(dispatch) {
  return {
    boundGetAsset: (collection, entry) => boundGetAsset(dispatch, collection, entry)
  };
}
function mergeProps(stateProps, dispatchProps, ownProps) {
  return {
    ...stateProps,
    ...dispatchProps,
    ...ownProps,
    getAsset: dispatchProps.boundGetAsset(ownProps.collection, ownProps.entry)
  };
}
export default connect(mapStateToProps, mapDispatchToProps, mergeProps)(PreviewPane);