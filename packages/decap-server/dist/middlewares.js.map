{"version":3,"file":"middlewares.js","mappings":"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","sources":["webpack://decap-server/external commonjs \"morgan\"","webpack://decap-server/./src/middlewares/utils/entries.ts","webpack://decap-server/external commonjs \"winston\"","webpack://decap-server/../decap-cms-lib-util/src/APIUtils.ts","webpack://decap-server/external commonjs \"express\"","webpack://decap-server/external commonjs \"what-the-diff\"","webpack://decap-server/external commonjs \"async-mutex\"","webpack://decap-server/./src/middlewares/utils/fs.ts","webpack://decap-server/external commonjs \"cors\"","webpack://decap-server/external commonjs \"@hapi/joi\"","webpack://decap-server/./src/middlewares/joi/customValidators.ts","webpack://decap-server/./src/middlewares/localFs/index.ts","webpack://decap-server/external commonjs \"simple-git\"","webpack://decap-server/./src/middlewares/common/index.ts","webpack://decap-server/external node-commonjs \"fs\"","webpack://decap-server/external node-commonjs \"path\"","webpack://decap-server/./src/logger.ts","webpack://decap-server/./src/middlewares/joi/index.ts","webpack://decap-server/./src/middlewares/localGit/index.ts","webpack://decap-server/external node-commonjs \"crypto\"","webpack://decap-server/webpack/bootstrap","webpack://decap-server/./src/middlewares.ts"],"sourcesContent":["module.exports = require(\"morgan\");","import crypto from 'crypto';\nimport path from 'path';\nimport { promises as fs } from 'fs';\n\nfunction sha256(buffer: Buffer) {\n  return crypto.createHash('sha256').update(buffer).digest('hex');\n}\n\n// normalize windows os path format\nfunction normalizePath(path: string) {\n  return path.replace(/\\\\/g, '/');\n}\n\nexport async function entriesFromFiles(\n  repoPath: string,\n  files: { path: string; label?: string }[],\n) {\n  return Promise.all(\n    files.map(async file => {\n      try {\n        const content = await fs.readFile(path.join(repoPath, file.path));\n        return {\n          data: content.toString(),\n          file: { path: normalizePath(file.path), label: file.label, id: sha256(content) },\n        };\n      } catch (e) {\n        return {\n          data: null,\n          file: { path: normalizePath(file.path), label: file.label, id: null },\n        };\n      }\n    }),\n  );\n}\n\nexport async function readMediaFile(repoPath: string, file: string) {\n  const encoding = 'base64';\n  const buffer = await fs.readFile(path.join(repoPath, file));\n  const id = sha256(buffer);\n\n  return {\n    id,\n    content: buffer.toString(encoding),\n    encoding,\n    path: normalizePath(file),\n    name: path.basename(file),\n  };\n}\n","module.exports = require(\"winston\");","export const CMS_BRANCH_PREFIX = 'cms';\nexport const DEFAULT_PR_BODY = 'Automatically generated by Decap CMS';\nexport const MERGE_COMMIT_MESSAGE = 'Automatically generated. Merged on Decap CMS.';\n\nconst DEFAULT_DECAP_CMS_LABEL_PREFIX = 'decap-cms/';\n\nfunction getLabelPrefix(labelPrefix: string) {\n  return labelPrefix || DEFAULT_DECAP_CMS_LABEL_PREFIX;\n}\n\nexport function isCMSLabel(label: string, labelPrefix: string) {\n  return label.startsWith(getLabelPrefix(labelPrefix));\n}\n\nexport function labelToStatus(label: string, labelPrefix: string) {\n  return label.slice(getLabelPrefix(labelPrefix).length);\n}\n\nexport function statusToLabel(status: string, labelPrefix: string) {\n  return `${getLabelPrefix(labelPrefix)}${status}`;\n}\n\nexport function generateContentKey(collectionName: string, slug: string) {\n  return `${collectionName}/${slug}`;\n}\n\nexport function parseContentKey(contentKey: string) {\n  const index = contentKey.indexOf('/');\n  return { collection: contentKey.slice(0, index), slug: contentKey.slice(index + 1) };\n}\n\nexport function contentKeyFromBranch(branch: string) {\n  return branch.slice(`${CMS_BRANCH_PREFIX}/`.length);\n}\n\nexport function branchFromContentKey(contentKey: string) {\n  return `${CMS_BRANCH_PREFIX}/${contentKey}`;\n}\n","module.exports = require(\"express\");","module.exports = require(\"what-the-diff\");","module.exports = require(\"async-mutex\");","/* eslint-disable @typescript-eslint/no-explicit-any */\ndeclare const require: any;\nconst path = require('path');\nconst fs = require('fs').promises;\n\nasync function listFiles(dir: string, extension: string, depth: number): Promise<string[]> {\n  if (depth <= 0) {\n    return [];\n  }\n\n  try {\n    const dirents = await fs.readdir(dir, { withFileTypes: true });\n    const files = await Promise.all(\n      dirents.map((dirent: any) => {\n        const res = path.join(dir, dirent.name);\n        return dirent.isDirectory()\n          ? listFiles(res, extension, depth - 1)\n          : [res].filter(f => f.endsWith(extension));\n      }),\n    );\n    return ([] as string[]).concat(...files);\n  } catch (e) {\n    return [];\n  }\n}\n\nexport async function listRepoFiles(\n  repoPath: string,\n  folder: string,\n  extension: string,\n  depth: number,\n) {\n  const abs = path.join(repoPath, folder);\n  const files = await listFiles(abs, extension, depth);\n  return files.map(f => f.slice(repoPath.length + 1));\n}\n\n// List one-level children (files and directories) under a target folder relative to repoPath\nexport async function listDirChildren(\n  repoPath: string,\n  targetRelativeFolder: string,\n): Promise<{ type: 'file' | 'directory'; path: string; name: string }[]> {\n  const abs = path.join(repoPath, targetRelativeFolder);\n  try {\n    const dirents = await fs.readdir(abs, { withFileTypes: true });\n    return dirents.map((dirent: any) => {\n      const absChild = path.join(abs, dirent.name);\n      const relPath = absChild.slice(repoPath.length + 1);\n      return { type: dirent.isDirectory() ? 'directory' : 'file', path: relPath, name: dirent.name };\n    });\n  } catch (e) {\n    return [];\n  }\n}\n\nexport async function writeFile(filePath: string, content: any) {\n  await fs.mkdir(path.dirname(filePath), { recursive: true });\n  await fs.writeFile(filePath, content);\n}\n\nexport async function deleteFile(repoPath: string, filePath: string) {\n  await fs.unlink(path.join(repoPath, filePath)).catch(() => undefined);\n}\n\nasync function moveFile(from: string, to: string) {\n  await fs.mkdir(path.dirname(to), { recursive: true });\n  await fs.rename(from, to);\n}\n\nexport async function move(from: string, to: string) {\n  // move file\n  await moveFile(from, to);\n\n  // move children\n  const sourceDir = path.dirname(from);\n  const destDir = path.dirname(to);\n  const allFiles = await listFiles(sourceDir, '', 100);\n  await Promise.all(allFiles.map(file => moveFile(file, file.replace(sourceDir, destDir))));\n}\n\nexport async function getUpdateDate(repoPath: string, filePath: string) {\n  return fs\n    .stat(path.join(repoPath, filePath))\n    .then((stat: any) => stat.mtime)\n    .catch(() => new Date());\n}\n","module.exports = require(\"cors\");","module.exports = require(\"@hapi/joi\");","import Joi from '@hapi/joi';\nimport path from 'path';\n\nexport function pathTraversal(repoPath: string) {\n  return Joi.extend({\n    type: 'path',\n    base: Joi.string().required(),\n    messages: {\n      'path.invalid': '{{#label}} must resolve to a path under the configured repository',\n    },\n    validate(value, helpers) {\n      const resolvedPath = path.join(repoPath, value);\n      if (!resolvedPath.startsWith(repoPath)) {\n        return { value, errors: helpers.error('path.invalid') };\n      }\n    },\n  }).path();\n}\n","import path from 'path';\n\nimport { defaultSchema, joi } from '../joi';\nimport { pathTraversal } from '../joi/customValidators';\nimport { listRepoFiles, deleteFile, writeFile, move, listDirChildren } from '../utils/fs';\nimport { entriesFromFiles, readMediaFile } from '../utils/entries';\n\nimport type {\n  EntriesByFolderParams,\n  EntriesByFilesParams,\n  GetEntryParams,\n  PersistEntryParams,\n  GetMediaParams,\n  GetMediaFileParams,\n  PersistMediaParams,\n  DeleteFileParams,\n  DeleteFilesParams,\n  DataFile,\n} from '../types';\nimport type express from 'express';\nimport type winston from 'winston';\n\ntype FsOptions = {\n  repoPath: string;\n  logger: winston.Logger;\n};\n\nexport function localFsMiddleware({ repoPath, logger }: FsOptions) {\n  return async function (req: express.Request, res: express.Response) {\n    try {\n      const { body } = req;\n      try { logger.debug(`[fs] action=${body.action}`); } catch (_) {}\n\n      switch (body.action) {\n        case 'info': {\n          res.json({\n            repo: path.basename(repoPath),\n            publish_modes: ['simple'],\n            type: 'local_fs',\n          });\n          break;\n        }\n        case 'entriesByFolder': {\n          const payload = body.params as EntriesByFolderParams;\n          const { folder, extension, depth } = payload;\n          const entries = await listRepoFiles(repoPath, folder, extension, depth).then(files =>\n            entriesFromFiles(\n              repoPath,\n              files.map(file => ({ path: file })),\n            ),\n          );\n          res.json(entries);\n          break;\n        }\n        case 'entriesByFiles': {\n          const payload = body.params as EntriesByFilesParams;\n          const entries = await entriesFromFiles(repoPath, payload.files);\n          res.json(entries);\n          break;\n        }\n        case 'getEntry': {\n          const payload = body.params as GetEntryParams;\n          const [entry] = await entriesFromFiles(repoPath, [{ path: payload.path }]);\n          res.json(entry);\n          break;\n        }\n        case 'persistEntry': {\n          const {\n            entry,\n            dataFiles = [entry as DataFile],\n            assets,\n          } = body.params as PersistEntryParams;\n          try {\n            logger.info(\n              `[fs] persistEntry dataFiles=${dataFiles.length} assets=${assets.length}`,\n            );\n          } catch (_) {}\n          await Promise.all(\n            dataFiles.map(dataFile => writeFile(path.join(repoPath, dataFile.path), dataFile.raw)),\n          );\n          // save assets\n          await Promise.all(\n            assets.map(a =>\n              writeFile(path.join(repoPath, a.path), Buffer.from(a.content, a.encoding)),\n            ),\n          );\n          if (dataFiles.every(dataFile => dataFile.newPath)) {\n            dataFiles.forEach(async dataFile => {\n              await move(\n                path.join(repoPath, dataFile.path),\n                path.join(repoPath, dataFile.newPath!),\n              );\n            });\n          }\n          try { logger.debug('[fs] persistEntry complete'); } catch (_) {}\n          res.json({ message: 'entry persisted' });\n          break;\n        }\n        case 'getMedia': {\n          const { mediaFolder, subpath = '' } = body.params as GetMediaParams & { subpath?: string };\n          // Use absolute, normalized paths for safe comparison\n          const root = path.resolve(repoPath, mediaFolder);\n          const norm = path.normalize(subpath || '').replace(/^\\\\+|\\/+$/g, '');\n          if (norm.includes('..')) {\n            return res.status(400).json({ error: 'Invalid subpath' });\n          }\n          const target = path.resolve(root, norm);\n          const rootWithSep = root.endsWith(path.sep) ? root : root + path.sep;\n          if (!(target === root || target.startsWith(rootWithSep))) {\n            return res.status(400).json({ error: 'Invalid subpath' });\n          }\n          const relTarget = path.relative(repoPath, target);\n          // one-level list of directories and files\n          const children = await listDirChildren(repoPath, relTarget);\n          const files = children.filter(c => c.type === 'file').map(c => c.path);\n          const dirs = children.filter(c => c.type === 'directory');\n          const serializedFiles = await Promise.all(files.map(file => readMediaFile(repoPath, file)));\n          const dirEntries = dirs.map(d => ({\n            id: d.path,\n            name: d.name,\n            path: d.path,\n            type: 'directory',\n            content: '',\n            encoding: 'base64',\n          }));\n          try {\n            logger.debug(\n              `[fs] getMedia mediaFolder=${mediaFolder} subpath=${norm} dirs=${dirs.length} files=${files.length}`,\n            );\n          } catch (_) {}\n          res.json([...dirEntries, ...serializedFiles]);\n          break;\n        }\n        case 'getMediaFile': {\n          const { path } = body.params as GetMediaFileParams;\n          try { logger.debug(`[fs] getMediaFile path=${path}`); } catch (_) {}\n          const mediaFile = await readMediaFile(repoPath, path);\n          res.json(mediaFile);\n          break;\n        }\n        case 'persistMedia': {\n          const { asset } = body.params as PersistMediaParams;\n          try {\n            logger.info(\n              `[fs] persistMedia path=${asset.path} bytes=${(asset.content && asset.content.length) || 0} encoding=${asset.encoding}`,\n            );\n          } catch (_) {}\n          await writeFile(\n            path.join(repoPath, asset.path),\n            Buffer.from(asset.content, asset.encoding),\n          );\n          const file = await readMediaFile(repoPath, asset.path);\n          try { logger.debug('[fs] persistMedia complete'); } catch (_) {}\n          res.json(file);\n          break;\n        }\n        case 'deleteFile': {\n          const { path: filePath } = body.params as DeleteFileParams;\n          await deleteFile(repoPath, filePath);\n          res.json({ message: `deleted file ${filePath}` });\n          break;\n        }\n        case 'deleteFiles': {\n          const { paths } = body.params as DeleteFilesParams;\n          await Promise.all(paths.map(filePath => deleteFile(repoPath, filePath)));\n          res.json({ message: `deleted files ${paths.join(', ')}` });\n          break;\n        }\n        case 'getDeployPreview': {\n          res.json(null);\n          break;\n        }\n        default: {\n          const message = `Unknown action ${body.action}`;\n          res.status(422).json({ error: message });\n          break;\n        }\n      }\n    } catch (e) {\n      logger.error(\n        `Error handling ${JSON.stringify(req.body)}: ${\n          e instanceof Error ? e.message : 'Unknown error'\n        }`,\n      );\n      res.status(500).json({ error: 'Unknown error' });\n    }\n  };\n}\n\nexport function getSchema({ repoPath }: { repoPath: string }) {\n  const schema = defaultSchema({ path: pathTraversal(repoPath) });\n  return schema;\n}\n\ntype Options = {\n  logger: winston.Logger;\n};\n\nexport async function registerMiddleware(app: express.Express, options: Options) {\n  const { logger } = options;\n  const repoPath = path.resolve(process.env.GIT_REPO_DIRECTORY || process.cwd());\n  app.post('/api/v1', joi(getSchema({ repoPath })));\n  app.post('/api/v1', localFsMiddleware({ repoPath, logger }));\n  logger.info(`Decap CMS File System Proxy Server configured with ${repoPath}`);\n}\n","module.exports = require(\"simple-git\");","import express from 'express';\nimport morgan from 'morgan';\nimport cors from 'cors';\n\nimport type winston from 'winston';\n\nexport type Options = {\n  logger: winston.Logger;\n};\n\nexport function registerCommonMiddlewares(app: express.Express, options: Options) {\n  const { logger } = options;\n  const stream = {\n    write: (message: string) => {\n      logger.debug(String(message).trim());\n    },\n  };\n  app.use(morgan('combined', { stream }));\n  app.use(cors());\n  app.use(express.json({ limit: '50mb' }));\n}\n","module.exports = require(\"fs\");","module.exports = require(\"path\");","import winston from 'winston';\n\nconst { combine, colorize, simple } = winston.format;\n\ntype LogOptions = {\n  level: string;\n};\n\nexport function createLogger({ level }: LogOptions) {\n  return winston.createLogger({\n    level,\n    format: combine(colorize(), simple()),\n    transports: [new winston.transports.Console()],\n  });\n}\n","import Joi from '@hapi/joi';\n\nimport type express from 'express';\n\nconst allowedActions = [\n  'info',\n  'entriesByFolder',\n  'entriesByFiles',\n  'getEntry',\n  'unpublishedEntries',\n  'unpublishedEntry',\n  'unpublishedEntryDataFile',\n  'unpublishedEntryMediaFile',\n  'deleteUnpublishedEntry',\n  'persistEntry',\n  'updateUnpublishedEntryStatus',\n  'publishUnpublishedEntry',\n  'getMedia',\n  'getMediaFile',\n  'persistMedia',\n  'deleteFile',\n  'deleteFiles',\n  'getDeployPreview',\n];\n\nconst requiredString = Joi.string().required();\nconst requiredNumber = Joi.number().required();\nconst requiredBool = Joi.bool().required();\n\nconst collection = requiredString;\nconst slug = requiredString;\n\nexport function defaultSchema({ path = requiredString } = {}) {\n  const defaultParams = Joi.object({\n    branch: requiredString,\n  });\n\n  const asset = Joi.object({\n    path,\n    content: requiredString,\n    encoding: requiredString.valid('base64'),\n  });\n\n  const dataFile = Joi.object({\n    slug: requiredString,\n    path,\n    raw: requiredString,\n    newPath: path.optional(),\n  });\n\n  const params = Joi.when('action', {\n    switch: [\n      {\n        is: 'info',\n        then: Joi.allow(),\n      },\n      {\n        is: 'entriesByFolder',\n        then: defaultParams\n          .keys({\n            folder: path,\n            extension: requiredString,\n            depth: requiredNumber,\n          })\n          .required(),\n      },\n      {\n        is: 'entriesByFiles',\n        then: defaultParams.keys({\n          files: Joi.array()\n            .items(Joi.object({ path, label: Joi.string() }))\n            .required(),\n        }),\n      },\n      {\n        is: 'getEntry',\n        then: defaultParams\n          .keys({\n            path,\n          })\n          .required(),\n      },\n      {\n        is: 'unpublishedEntries',\n        then: defaultParams.keys({ branch: requiredString }).required(),\n      },\n      {\n        is: 'unpublishedEntry',\n        then: defaultParams\n          .keys({\n            id: Joi.string().optional(),\n            collection: Joi.string().optional(),\n            slug: Joi.string().optional(),\n            cmsLabelPrefix: Joi.string().optional(),\n          })\n          .required(),\n      },\n      {\n        is: 'unpublishedEntryDataFile',\n        then: defaultParams\n          .keys({\n            collection,\n            slug,\n            id: requiredString,\n            path: requiredString,\n          })\n          .required(),\n      },\n      {\n        is: 'unpublishedEntryMediaFile',\n        then: defaultParams\n          .keys({\n            collection,\n            slug,\n            id: requiredString,\n            path: requiredString,\n          })\n          .required(),\n      },\n      {\n        is: 'deleteUnpublishedEntry',\n        then: defaultParams\n          .keys({\n            collection,\n            slug,\n          })\n          .required(),\n      },\n      {\n        is: 'persistEntry',\n        then: defaultParams\n          .keys({\n            cmsLabelPrefix: Joi.string().optional(),\n            entry: dataFile, // entry is kept for backwards compatibility\n            dataFiles: Joi.array().items(dataFile),\n            assets: Joi.array().items(asset).required(),\n            options: Joi.object({\n              collectionName: Joi.string(),\n              commitMessage: requiredString,\n              useWorkflow: requiredBool,\n              status: requiredString,\n            }).required(),\n          })\n          .xor('entry', 'dataFiles')\n          .required(),\n      },\n      {\n        is: 'updateUnpublishedEntryStatus',\n        then: defaultParams\n          .keys({\n            collection,\n            slug,\n            newStatus: requiredString,\n            cmsLabelPrefix: Joi.string().optional(),\n          })\n          .required(),\n      },\n      {\n        is: 'publishUnpublishedEntry',\n        then: defaultParams\n          .keys({\n            collection,\n            slug,\n          })\n          .required(),\n      },\n      {\n        is: 'getMedia',\n        then: defaultParams\n          .keys({\n            mediaFolder: path,\n          })\n          .required(),\n      },\n      {\n        is: 'getMediaFile',\n        then: defaultParams\n          .keys({\n            path,\n          })\n          .required(),\n      },\n      {\n        is: 'persistMedia',\n        then: defaultParams\n          .keys({\n            asset: asset.required(),\n            options: Joi.object({\n              commitMessage: requiredString,\n            }).required(),\n          })\n          .required(),\n      },\n      {\n        is: 'deleteFile',\n        then: defaultParams\n          .keys({\n            path,\n            options: Joi.object({\n              commitMessage: requiredString,\n            }).required(),\n          })\n          .required(),\n      },\n      {\n        is: 'deleteFiles',\n        then: defaultParams\n          .keys({\n            paths: Joi.array().items(path).min(1).required(),\n            options: Joi.object({\n              commitMessage: requiredString,\n            }).required(),\n          })\n          .required(),\n      },\n      {\n        is: 'getDeployPreview',\n        then: defaultParams\n          .keys({\n            collection,\n            slug,\n          })\n          .required(),\n      },\n    ],\n    otherwise: Joi.forbidden(),\n  });\n\n  return Joi.object({\n    action: Joi.valid(...allowedActions).required(),\n    params,\n  });\n}\n\nexport function joi(schema: Joi.Schema) {\n  return (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    const { error } = schema.validate(req.body, { allowUnknown: true });\n    if (error) {\n      const { details } = error;\n      const message = details.map(i => i.message).join(',');\n      res.status(422).json({ error: message });\n    } else {\n      next();\n    }\n  };\n}\n","import path from 'path';\nimport { promises as fs } from 'fs';\nimport {\n  branchFromContentKey,\n  generateContentKey,\n  contentKeyFromBranch,\n  CMS_BRANCH_PREFIX,\n  statusToLabel,\n  labelToStatus,\n  parseContentKey,\n} from 'decap-cms-lib-util/src/APIUtils';\nimport { parse } from 'what-the-diff';\n// eslint-disable-next-line import/no-named-as-default\nimport simpleGit from 'simple-git';\nimport { Mutex, withTimeout } from 'async-mutex';\n\nimport { defaultSchema, joi } from '../joi';\nimport { pathTraversal } from '../joi/customValidators';\nimport { listRepoFiles, writeFile, move, deleteFile, getUpdateDate, listDirChildren } from '../utils/fs';\nimport { entriesFromFiles, readMediaFile } from '../utils/entries';\n\nimport type {\n  EntriesByFolderParams,\n  EntriesByFilesParams,\n  GetEntryParams,\n  DefaultParams,\n  UnpublishedEntryParams,\n  PersistEntryParams,\n  GetMediaParams,\n  Asset,\n  PublishUnpublishedEntryParams,\n  PersistMediaParams,\n  DeleteFileParams,\n  UpdateUnpublishedEntryStatusParams,\n  DataFile,\n  GetMediaFileParams,\n  DeleteEntryParams,\n  DeleteFilesParams,\n  UnpublishedEntryDataFileParams,\n  UnpublishedEntryMediaFileParams,\n} from '../types';\nimport type express from 'express';\nimport type winston from 'winston';\nimport type { SimpleGit } from 'simple-git';\n\nasync function commit(git: SimpleGit, commitMessage: string) {\n  await git.add('.');\n  await git.commit(commitMessage, undefined, {\n    // setting the value to a string passes name=value\n    // any other value passes just the key\n    '--no-verify': null,\n    '--no-gpg-sign': null,\n  });\n}\n\nasync function getCurrentBranch(git: SimpleGit) {\n  const currentBranch = await git.branchLocal().then(summary => summary.current);\n  return currentBranch;\n}\n\nasync function runOnBranch<T>(git: SimpleGit, branch: string, func: () => Promise<T>) {\n  const currentBranch = await getCurrentBranch(git);\n  try {\n    if (currentBranch !== branch) {\n      await git.checkout(branch);\n    }\n    const result = await func();\n    return result;\n  } finally {\n    await git.checkout(currentBranch);\n  }\n}\n\nfunction branchDescription(branch: string) {\n  return `branch.${branch}.description`;\n}\n\ntype GitOptions = {\n  repoPath: string;\n  logger: winston.Logger;\n};\n\nasync function commitEntry(\n  git: SimpleGit,\n  repoPath: string,\n  dataFiles: DataFile[],\n  assets: Asset[],\n  commitMessage: string,\n) {\n  // save entry content\n  await Promise.all(\n    dataFiles.map(dataFile => writeFile(path.join(repoPath, dataFile.path), dataFile.raw)),\n  );\n  // save assets\n  await Promise.all(\n    assets.map(a => writeFile(path.join(repoPath, a.path), Buffer.from(a.content, a.encoding))),\n  );\n  if (dataFiles.every(dataFile => dataFile.newPath)) {\n    dataFiles.forEach(async dataFile => {\n      await move(path.join(repoPath, dataFile.path), path.join(repoPath, dataFile.newPath!));\n    });\n  }\n\n  // commits files\n  await commit(git, commitMessage);\n}\n\nasync function rebase(git: SimpleGit, branch: string) {\n  const gpgSign = await git.raw(['config', 'commit.gpgsign']);\n  try {\n    if (gpgSign === 'true') {\n      await git.addConfig('commit.gpgsign', 'false');\n    }\n    await git.rebase([branch, '--no-verify']);\n  } finally {\n    if (gpgSign === 'true') {\n      await git.addConfig('commit.gpgsign', gpgSign);\n    }\n  }\n}\n\nasync function merge(git: SimpleGit, from: string, to: string) {\n  const gpgSign = await git.raw(['config', 'commit.gpgsign']);\n  try {\n    if (gpgSign === 'true') {\n      await git.addConfig('commit.gpgsign', 'false');\n    }\n    await git.mergeFromTo(from, to);\n  } finally {\n    if (gpgSign === 'true') {\n      await git.addConfig('commit.gpgsign', gpgSign);\n    }\n  }\n}\n\nasync function isBranchExists(git: SimpleGit, branch: string) {\n  const branchExists = await git.branchLocal().then(({ all }) => all.includes(branch));\n  return branchExists;\n}\n\nasync function getDiffs(git: SimpleGit, source: string, dest: string) {\n  const rawDiff = await git.diff([source, dest]);\n  const diffs = parse(rawDiff).map(d => {\n    const oldPath = d.oldPath?.replace(/b\\//, '') || '';\n    const newPath = d.newPath?.replace(/b\\//, '') || '';\n    const path = newPath || (oldPath as string);\n    return {\n      oldPath,\n      newPath,\n      status: d.status,\n      newFile: d.status === 'added',\n      path,\n      id: path,\n      binary: d.binary || /.svg$/.test(path),\n    };\n  });\n  return diffs;\n}\n\nexport async function validateRepo({ repoPath }: { repoPath: string }) {\n  const git = simpleGit(repoPath);\n  const isRepo = await git.checkIsRepo();\n  if (!isRepo) {\n    throw Error(`${repoPath} is not a valid git repository`);\n  }\n}\n\nexport function getSchema({ repoPath }: { repoPath: string }) {\n  const schema = defaultSchema({ path: pathTraversal(repoPath) });\n  return schema;\n}\n\nexport function localGitMiddleware({ repoPath, logger }: GitOptions) {\n  const git = simpleGit(repoPath);\n\n  // we can only perform a single git operation at any given time\n  const mutex = withTimeout(new Mutex(), 3000, new Error('Request timed out'));\n\n  return async function (req: express.Request, res: express.Response) {\n    let release;\n    try {\n      release = await mutex.acquire();\n      const { body } = req;\n      if (body.action === 'info') {\n        res.json({\n          repo: path.basename(repoPath),\n          publish_modes: ['simple', 'editorial_workflow'],\n          type: 'local_git',\n        });\n        return;\n      }\n      const { branch } = body.params as DefaultParams;\n\n      const branchExists = await isBranchExists(git, branch);\n      if (!branchExists) {\n        const message = `Default branch '${branch}' doesn't exist`;\n        res.status(422).json({ error: message });\n        return;\n      }\n\n      switch (body.action) {\n        case 'entriesByFolder': {\n          const payload = body.params as EntriesByFolderParams;\n          const { folder, extension, depth } = payload;\n          const entries = await runOnBranch(git, branch, () =>\n            listRepoFiles(repoPath, folder, extension, depth).then(files =>\n              entriesFromFiles(\n                repoPath,\n                files.map(file => ({ path: file })),\n              ),\n            ),\n          );\n          res.json(entries);\n          break;\n        }\n        case 'entriesByFiles': {\n          const payload = body.params as EntriesByFilesParams;\n          const entries = await runOnBranch(git, branch, () =>\n            entriesFromFiles(repoPath, payload.files),\n          );\n          res.json(entries);\n          break;\n        }\n        case 'getEntry': {\n          const payload = body.params as GetEntryParams;\n          const [entry] = await runOnBranch(git, branch, () =>\n            entriesFromFiles(repoPath, [{ path: payload.path }]),\n          );\n          res.json(entry);\n          break;\n        }\n        case 'unpublishedEntries': {\n          const cmsBranches = await git\n            .branchLocal()\n            .then(result => result.all.filter(b => b.startsWith(`${CMS_BRANCH_PREFIX}/`)));\n          res.json(cmsBranches.map(contentKeyFromBranch));\n          break;\n        }\n        case 'unpublishedEntry': {\n          let { id, collection, slug, cmsLabelPrefix } = body.params as UnpublishedEntryParams;\n          if (id) {\n            ({ collection, slug } = parseContentKey(id));\n          }\n          const contentKey = generateContentKey(collection as string, slug as string);\n          const cmsBranch = branchFromContentKey(contentKey);\n          const branchExists = await isBranchExists(git, cmsBranch);\n          if (branchExists) {\n            const diffs = await getDiffs(git, branch, cmsBranch);\n            const label = await git.raw(['config', branchDescription(cmsBranch)]);\n            const status = label && labelToStatus(label.trim(), cmsLabelPrefix || '');\n            const updatedAt =\n              diffs.length >= 0\n                ? await runOnBranch(git, cmsBranch, async () => {\n                    const dates = await Promise.all(\n                      diffs.map(({ newPath }) => getUpdateDate(repoPath, newPath)),\n                    );\n                    return dates.reduce((a, b) => {\n                      return a > b ? a : b;\n                    });\n                  })\n                : new Date();\n            const unpublishedEntry = {\n              collection,\n              slug,\n              status,\n              diffs,\n              updatedAt,\n            };\n            res.json(unpublishedEntry);\n          } else {\n            return res.status(404).json({ message: 'Not Found' });\n          }\n          break;\n        }\n        case 'unpublishedEntryDataFile': {\n          const { path, collection, slug } = body.params as UnpublishedEntryDataFileParams;\n          const contentKey = generateContentKey(collection as string, slug as string);\n          const cmsBranch = branchFromContentKey(contentKey);\n          const [entry] = await runOnBranch(git, cmsBranch, () =>\n            entriesFromFiles(repoPath, [{ path }]),\n          );\n          res.json({ data: entry.data });\n          break;\n        }\n        case 'unpublishedEntryMediaFile': {\n          const { path, collection, slug } = body.params as UnpublishedEntryMediaFileParams;\n          const contentKey = generateContentKey(collection as string, slug as string);\n          const cmsBranch = branchFromContentKey(contentKey);\n          const file = await runOnBranch(git, cmsBranch, () => readMediaFile(repoPath, path));\n          res.json(file);\n          break;\n        }\n        case 'deleteUnpublishedEntry': {\n          const { collection, slug } = body.params as DeleteEntryParams;\n          const contentKey = generateContentKey(collection, slug);\n          const cmsBranch = branchFromContentKey(contentKey);\n          const currentBranch = await getCurrentBranch(git);\n          if (currentBranch === cmsBranch) {\n            await git.checkoutLocalBranch(branch);\n          }\n          await git.branch(['-D', cmsBranch]);\n          res.json({ message: `deleted branch: ${cmsBranch}` });\n          break;\n        }\n        case 'persistEntry': {\n          const {\n            cmsLabelPrefix,\n            entry,\n            dataFiles = [entry as DataFile],\n            assets,\n            options,\n          } = body.params as PersistEntryParams;\n\n          try { logger.info(`[git] persistEntry dataFiles=${dataFiles.length} assets=${assets.length} useWorkflow=${options.useWorkflow} status=${options.status}`); } catch (_) {}\n\n          if (!options.useWorkflow) {\n            await runOnBranch(git, branch, async () => {\n              await commitEntry(git, repoPath, dataFiles, assets, options.commitMessage);\n            });\n          } else {\n            const slug = dataFiles[0].slug;\n            const collection = options.collectionName as string;\n            const contentKey = generateContentKey(collection, slug);\n            const cmsBranch = branchFromContentKey(contentKey);\n            await runOnBranch(git, branch, async () => {\n              const branchExists = await isBranchExists(git, cmsBranch);\n              if (branchExists) {\n                await git.checkout(cmsBranch);\n              } else {\n                await git.checkoutLocalBranch(cmsBranch);\n              }\n              await rebase(git, branch);\n              const diffs = await getDiffs(git, branch, cmsBranch);\n              // delete media files that have been removed from the entry\n              const toDelete = diffs.filter(\n                d => d.binary && !assets.map(a => a.path).includes(d.path),\n              );\n              await Promise.all(toDelete.map(f => fs.unlink(path.join(repoPath, f.path))));\n              await commitEntry(git, repoPath, dataFiles, assets, options.commitMessage);\n\n              // add status for new entries\n              if (!branchExists) {\n                const description = statusToLabel(options.status, cmsLabelPrefix || '');\n                await git.addConfig(branchDescription(cmsBranch), description);\n              }\n            });\n          }\n          try { logger.debug('[git] persistEntry complete'); } catch (_) {}\n          res.json({ message: 'entry persisted' });\n          break;\n        }\n        case 'updateUnpublishedEntryStatus': {\n          const { collection, slug, newStatus, cmsLabelPrefix } =\n            body.params as UpdateUnpublishedEntryStatusParams;\n          const contentKey = generateContentKey(collection, slug);\n          const cmsBranch = branchFromContentKey(contentKey);\n          const description = statusToLabel(newStatus, cmsLabelPrefix || '');\n          await git.addConfig(branchDescription(cmsBranch), description);\n          res.json({ message: `${branch} description was updated to ${description}` });\n          break;\n        }\n        case 'publishUnpublishedEntry': {\n          const { collection, slug } = body.params as PublishUnpublishedEntryParams;\n          const contentKey = generateContentKey(collection, slug);\n          const cmsBranch = branchFromContentKey(contentKey);\n          await merge(git, cmsBranch, branch);\n          await git.deleteLocalBranch(cmsBranch);\n          res.json({ message: `branch ${cmsBranch} merged to ${branch}` });\n          break;\n        }\n        case 'getMedia': {\n          const { mediaFolder, subpath = '' } = body.params as GetMediaParams & { subpath?: string };\n          try { logger.debug(`[git] getMedia mediaFolder=${mediaFolder} subpath=${subpath}`); } catch (_) {}\n          const mediaFiles = await runOnBranch(git, branch, async () => {\n            const root = path.resolve(repoPath, mediaFolder);\n            const norm = path.normalize(subpath || '').replace(/^\\/+|\\/+$/g, '');\n            const target = path.resolve(root, norm);\n            const rootWithSep = root.endsWith(path.sep) ? root : root + path.sep;\n            if (!(target === root || target.startsWith(rootWithSep))) {\n              throw new Error('Invalid subpath');\n            }\n            const targetRelative = path.relative(repoPath, target);\n            const children = await listDirChildren(repoPath, targetRelative);\n            const files = children.filter(c => c.type === 'file').map(c => c.path);\n            const dirs = children.filter(c => c.type === 'directory');\n            const serializedFiles = await Promise.all(files.map(file => readMediaFile(repoPath, file)));\n            const dirEntries = dirs.map(d => ({\n              id: d.path,\n              name: d.name,\n              path: d.path,\n              type: 'directory',\n              content: '',\n              encoding: 'base64',\n            }));\n            try { logger.debug(`[git] getMedia results dirs=${dirs.length} files=${files.length}`); } catch (_) {}\n            return [...dirEntries, ...serializedFiles];\n          });\n          res.json(mediaFiles);\n          break;\n        }\n        case 'getMediaFile': {\n          const { path } = body.params as GetMediaFileParams;\n          try { logger.debug(`[git] getMediaFile path=${path}`); } catch (_) {}\n          const mediaFile = await runOnBranch(git, branch, () => {\n            return readMediaFile(repoPath, path);\n          });\n          res.json(mediaFile);\n          break;\n        }\n        case 'persistMedia': {\n          const {\n            asset,\n            options: { commitMessage },\n          } = body.params as PersistMediaParams;\n          try { logger.info(`[git] persistMedia path=${asset.path} bytes=${(asset.content && asset.content.length) || 0} encoding=${asset.encoding}`); } catch (_) {}\n\n          const file = await runOnBranch(git, branch, async () => {\n            await writeFile(\n              path.join(repoPath, asset.path),\n              Buffer.from(asset.content, asset.encoding),\n            );\n            await commit(git, commitMessage);\n            return readMediaFile(repoPath, asset.path);\n          });\n          try { logger.debug('[git] persistMedia complete'); } catch (_) {}\n          res.json(file);\n          break;\n        }\n        case 'deleteFile': {\n          const {\n            path: filePath,\n            options: { commitMessage },\n          } = body.params as DeleteFileParams;\n          await runOnBranch(git, branch, async () => {\n            await deleteFile(repoPath, filePath);\n            await commit(git, commitMessage);\n          });\n          res.json({ message: `deleted file ${filePath}` });\n          break;\n        }\n        case 'deleteFiles': {\n          const {\n            paths,\n            options: { commitMessage },\n          } = body.params as DeleteFilesParams;\n          await runOnBranch(git, branch, async () => {\n            await Promise.all(paths.map(filePath => deleteFile(repoPath, filePath)));\n            await commit(git, commitMessage);\n          });\n          res.json({ message: `deleted files ${paths.join(', ')}` });\n          break;\n        }\n        case 'getDeployPreview': {\n          res.json(null);\n          break;\n        }\n        default: {\n          const message = `Unknown action ${body.action}`;\n          res.status(422).json({ error: message });\n          break;\n        }\n      }\n    } catch (e) {\n      logger.error(\n        `Error handling ${JSON.stringify(req.body)}: ${\n          e instanceof Error ? e.message : 'Unknown error'\n        }`,\n      );\n      res.status(500).json({ error: 'Unknown error' });\n    } finally {\n      release && release();\n    }\n  };\n}\n\ntype Options = {\n  logger: winston.Logger;\n};\n\nexport async function registerMiddleware(app: express.Express, options: Options) {\n  const { logger } = options;\n  const repoPath = path.resolve(process.env.GIT_REPO_DIRECTORY || process.cwd());\n  await validateRepo({ repoPath });\n  app.post('/api/v1', joi(getSchema({ repoPath })));\n  app.post('/api/v1', localGitMiddleware({ repoPath, logger }));\n  logger.info(`Decap CMS Git Proxy Server configured with ${repoPath}`);\n}\n","module.exports = require(\"crypto\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { registerCommonMiddlewares } from './middlewares/common';\nimport { registerMiddleware as localGit } from './middlewares/localGit';\nimport { registerMiddleware as localFs } from './middlewares/localFs';\nimport { createLogger } from './logger';\n\nimport type express from 'express';\n\ntype Options = {\n  logLevel?: string;\n};\n\nfunction createOptions(options: Options) {\n  return {\n    logger: createLogger({ level: options.logLevel || 'info' }),\n  };\n}\n\nexport async function registerLocalGit(app: express.Express, options: Options = {}) {\n  const opts = createOptions(options);\n  registerCommonMiddlewares(app, opts);\n  await localGit(app, opts);\n}\n\nexport async function registerLocalFs(app: express.Express, options: Options = {}) {\n  const opts = createOptions(options);\n  registerCommonMiddlewares(app, opts);\n  await localFs(app, opts);\n}\n"],"names":["module","exports","require","sha256","buffer","createHash","update","digest","normalizePath","path","replace","async","repoPath","files","Promise","all","map","file","content","readFile","join","data","toString","label","id","e","encoding","name","basename","getLabelPrefix","labelPrefix","CMS_BRANCH_PREFIX","DEFAULT_PR_BODY","MERGE_COMMIT_MESSAGE","startsWith","slice","length","status","collectionName","slug","contentKey","index","indexOf","collection","branch","fs","listFiles","dir","extension","depth","dirents","readdir","withFileTypes","dirent","res","isDirectory","filter","f","endsWith","concat","moveFile","from","to","mkdir","dirname","recursive","rename","folder","abs","targetRelativeFolder","relPath","type","filePath","writeFile","unlink","catch","sourceDir","destDir","allFiles","stat","then","mtime","Date","extend","base","string","required","messages","validate","value","helpers","errors","error","localFsMiddleware","logger","req","body","debug","action","_","json","repo","publish_modes","payload","params","entries","listRepoFiles","entriesFromFiles","entry","dataFiles","assets","info","dataFile","raw","a","Buffer","every","newPath","forEach","move","message","mediaFolder","subpath","root","resolve","norm","normalize","includes","target","rootWithSep","sep","relTarget","relative","children","listDirChildren","c","dirs","serializedFiles","readMediaFile","dirEntries","d","mediaFile","asset","deleteFile","paths","JSON","stringify","Error","getSchema","defaultSchema","pathTraversal","app","options","process","env","GIT_REPO_DIRECTORY","cwd","post","joi","stream","write","String","trim","use","limit","combine","colorize","simple","format","level","createLogger","transports","Console","allowedActions","requiredString","requiredNumber","number","requiredBool","bool","defaultParams","object","valid","optional","when","switch","is","allow","keys","array","items","cmsLabelPrefix","commitMessage","useWorkflow","xor","newStatus","min","otherwise","forbidden","schema","next","allowUnknown","details","i","commit","git","add","undefined","getCurrentBranch","branchLocal","summary","current","runOnBranch","func","currentBranch","checkout","branchDescription","commitEntry","isBranchExists","getDiffs","source","dest","rawDiff","diff","parse","oldPath","newFile","binary","test","validateRepo","checkIsRepo","localGitMiddleware","mutex","withTimeout","Mutex","release","acquire","cmsBranches","result","b","contentKeyFromBranch","parseContentKey","generateContentKey","cmsBranch","branchFromContentKey","diffs","labelToStatus","updatedAt","getUpdateDate","reduce","unpublishedEntry","checkoutLocalBranch","branchExists","gpgSign","addConfig","rebase","toDelete","description","statusToLabel","mergeFromTo","merge","deleteLocalBranch","mediaFiles","targetRelative","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call","createOptions","logLevel","opts","registerCommonMiddlewares"],"sourceRoot":""}